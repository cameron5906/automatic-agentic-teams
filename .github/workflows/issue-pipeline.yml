name: Issue Pipeline

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to process"
        required: true
        type: number
      # Resume mode inputs (for clarification response handling)
      resume_mode:
        description: "Whether this is a resume from clarification timeout"
        required: false
        type: boolean
        default: false
      resume_checkpoint_id:
        description: "Checkpoint ID for resume"
        required: false
        type: string
      clarification_response:
        description: "The clarification response from human"
        required: false
        type: string
      orchestrator_state:
        description: "JSON string of orchestrator outputs (for resume)"
        required: false
        type: string
      resume_from_agent:
        description: "Agent to resume from"
        required: false
        type: string
      resume_from_phase:
        description: "Phase to resume from"
        required: false
        type: string
      resume_planning_context:
        description: "Planning context for resumed agent"
        required: false
        type: string

concurrency:
  group: issue-pipeline-global
  cancel-in-progress: false

permissions:
  contents: write
  issues: write
  pull-requests: write

env:
  AGENTS_DEFINITIONS_PATH: working/agents/definitions
  AGENTS_MEMORY_PATH: working/agents/memory
  ISSUES_PATH: working/issues
  TEMPLATE_REPO_NAME: automatic-agentic-teams

jobs:
  orchestrate:
    name: Orchestrate Pipeline
    runs-on: ubuntu-latest
    # Skip orchestrator in resume mode - use provided state instead
    if: |
      github.event.repository.name != 'automatic-agentic-teams' &&
      inputs.resume_mode != true
    outputs:
      delegation: ${{ steps.parse.outputs.delegation }}
      activate_documentation_sheriff: ${{ steps.parse.outputs.activate_documentation_sheriff }}
      activate_infrastructure_engineer: ${{ steps.parse.outputs.activate_infrastructure_engineer }}
      activate_product_owner: ${{ steps.parse.outputs.activate_product_owner }}
      activate_project_manager: ${{ steps.parse.outputs.activate_project_manager }}
      activate_security_engineer: ${{ steps.parse.outputs.activate_security_engineer }}
      activate_software_engineer: ${{ steps.parse.outputs.activate_software_engineer }}
      activate_tech_lead: ${{ steps.parse.outputs.activate_tech_lead }}
      activate_test_engineer: ${{ steps.parse.outputs.activate_test_engineer }}
      activate_ux_designer: ${{ steps.parse.outputs.activate_ux_designer }}
      issue_context: ${{ steps.parse.outputs.issue_context }}
      agent_prompts: ${{ steps.parse.outputs.agent_prompts }}
      issue_number: ${{ steps.issue.outputs.number }}
      issue_file: ${{ steps.work_branch.outputs.issue_file }}
      work_branch: ${{ steps.parse.outputs.work_branch }}
      # Hotfix mode: skip planning agents and fast-track to implementation
      is_hotfix: ${{ steps.hotfix.outputs.is_hotfix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 50
          token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get issue details
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            // issues event: context.payload.issue.number
            // workflow_dispatch: context.payload.inputs.issue_number
            const issueNumber = Number(
              context.payload.issue?.number ??
              context.payload.inputs?.issue_number ??
              core.getInput('issue_number') ??
              0
            );

            if (!issueNumber) {
              throw new Error("No issue number found (issues event or workflow_dispatch input required).");
            }

            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            core.setOutput('number', issue.number);
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            core.setOutput('labels', issue.labels.map(l => l.name).join(','));
            core.setOutput('author', issue.user.login);
            core.setOutput('created_at', issue.created_at);

      # Detect hotfix mode from issue labels - fast-tracks implementation
      - name: Detect hotfix mode
        id: hotfix
        run: |
          LABELS="${{ steps.issue.outputs.labels }}"
          if echo "$LABELS" | grep -qiE '(hotfix|priority:critical)'; then
            echo "is_hotfix=true" >> "$GITHUB_OUTPUT"
            echo "ðŸš¨ HOTFIX MODE ACTIVATED - Skipping planning agents"
          else
            echo "is_hotfix=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Load agent definitions
        id: definitions
        run: |
          AGENTS_JSON="[]"
          if [ -d "${{ env.AGENTS_DEFINITIONS_PATH }}" ]; then
            AGENTS_JSON=$(find ${{ env.AGENTS_DEFINITIONS_PATH }} -name "*.md" -type f | while read file; do
              name=$(basename "$file" .md)
              echo "{\"name\": \"$name\", \"path\": \"$file\"}"
            done | jq -sc '.')
          fi
          # Use heredoc format for JSON output
          DELIM="EOF_$(openssl rand -hex 8)"
          {
            echo "agents<<$DELIM"
            echo "$AGENTS_JSON"
            echo "$DELIM"
          } >> "$GITHUB_OUTPUT"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Define orchestrator structured output schema (JSON, not JS)
        id: orchestrator_schema
        run: |
          cat > /tmp/orchestrator_output_schema.json <<'JSON'
          {
            "type": "object",
            "additionalProperties": false,
            "required": ["issue_context","delegation","branch"],
            "properties": {
              "issue_context": { "type": "string" },
              "branch": {
                "type": "object",
                "additionalProperties": false,
                "required": ["type","name"],
                "properties": {
                  "type": { "type": "string", "enum": ["feat","fix","chore","docs","refactor","test","ci"] },
                  "name": { "type": "string" }
                }
              },
              "delegation": {
                "type": "object",
                "additionalProperties": false,
                "required": ["documentation_sheriff","infrastructure_engineer","product_owner","project_manager","security_engineer","software_engineer","tech_lead","test_engineer","ux_designer"],
                "properties": {
                  "documentation_sheriff": { "type":"object","additionalProperties":false,"required":["activate","phase","prompt"],"properties":{"activate":{"type":"boolean"},"phase":{"type":"string","enum":["pre","post","both"]},"prompt":{"type":"string"}}},
                  "infrastructure_engineer": { "type":"object","additionalProperties":false,"required":["activate","phase","prompt"],"properties":{"activate":{"type":"boolean"},"phase":{"type":"string","enum":["pre","post","both"]},"prompt":{"type":"string"}}},
                  "security_engineer": { "type":"object","additionalProperties":false,"required":["activate","phase","prompt"],"properties":{"activate":{"type":"boolean"},"phase":{"type":"string","enum":["pre","post","both"]},"prompt":{"type":"string"}}},
                  "product_owner": { "type":"object","additionalProperties":false,"required":["activate","prompt"],"properties":{"activate":{"type":"boolean"},"prompt":{"type":"string"}}},
                  "project_manager": { "type":"object","additionalProperties":false,"required":["activate","prompt"],"properties":{"activate":{"type":"boolean"},"prompt":{"type":"string"}}},
                  "software_engineer": { "type":"object","additionalProperties":false,"required":["activate","prompt"],"properties":{"activate":{"type":"boolean"},"prompt":{"type":"string"}}},
                  "tech_lead": { "type":"object","additionalProperties":false,"required":["activate","prompt"],"properties":{"activate":{"type":"boolean"},"prompt":{"type":"string"}}},
                  "test_engineer": { "type":"object","additionalProperties":false,"required":["activate","prompt"],"properties":{"activate":{"type":"boolean"},"prompt":{"type":"string"}}},
                  "ux_designer": { "type":"object","additionalProperties":false,"required":["activate","prompt"],"properties":{"activate":{"type":"boolean"},"prompt":{"type":"string"}}}
                }
              }
            }
          }
          JSON

          echo "schema=$(jq -c . /tmp/orchestrator_output_schema.json)" >> "$GITHUB_OUTPUT"

      - name: Run orchestrator (OpenAI GPT-4o Structured Output)
        id: orchestrator
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.number }}
          ISSUE_TITLE: ${{ steps.issue.outputs.title }}
          ISSUE_BODY: ${{ steps.issue.outputs.body }}
          ISSUE_LABELS: ${{ steps.issue.outputs.labels }}
          AGENTS_JSON: ${{ steps.definitions.outputs.agents }}
        run: |
          set -euo pipefail

          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "OPENAI_API_KEY is missing. Add it as a repo secret."
            exit 1
          fi

          # Build the exact same prompt you were giving Claude
          # Check if hotfix mode is active
          IS_HOTFIX="${{ steps.hotfix.outputs.is_hotfix }}"

          SYSTEM_PROMPT=$(cat <<EOF
          You are the Pipeline Orchestrator. Your job is to analyze a GitHub issue and determine which agents should be activated to handle it.

          NON-NEGOTIABLE ROLE BOUNDARY:
          - You are a ROUTER, not a doer.
          - Do NOT propose code changes, do NOT implement fixes, do NOT draft patches.
          - Your only deliverable is the JSON object matching the schema.

          HOTFIX MODE (is_hotfix=${IS_HOTFIX}):
          If is_hotfix=true, this issue has 'hotfix' or 'priority:critical' labels. In hotfix mode:
          - Set all planning agent activations to false (product_owner, ux_designer, tech_lead)
          - Only activate: security_engineer (pre phase only), software_engineer, test_engineer
          - Use expedited prompts focused on minimal correct fix
          - Skip documentation_sheriff and infrastructure_engineer unless absolutely necessary
          - project_manager should still be activated for tracking
          EOF
          )

          USER_PROMPT=$(cat <<EOF
          ## Issue
          #${ISSUE_NUMBER}: ${ISSUE_TITLE}
          Labels: ${ISSUE_LABELS}

          Body:
          ${ISSUE_BODY}

          ## Available Agents (name + path)
          ${AGENTS_JSON}

          ## Output Rules (must follow)
          - Return ONLY valid JSON matching the schema.
          - Planning agents: ONLY update working/issues + working/agents/memory (no code changes)
          - Implementation/validation agents: may change code + commit.
          - Choose branch.type and branch.name:
            - type in: feat|fix|chore|docs|refactor|test|ci
            - name format: <type>/issue-<number>-<kebab-title> (<= ~80 chars, lowercase, hyphens only)
          EOF
          )

          # Compact schema for injection
          SCHEMA_JSON="$(jq -c . /tmp/orchestrator_output_schema.json)"

          # Build Responses API payload with strict JSON Schema structured output
          jq -n \
            --arg model "gpt-4o-2024-08-06" \
            --arg system "$SYSTEM_PROMPT" \
            --arg user "$USER_PROMPT" \
            --argjson schema "$SCHEMA_JSON" \
            '{
              model: $model,
              store: false,
              temperature: 0,
              max_output_tokens: 2500,
              input: [
                { role: "system", content: $system },
                { role: "user", content: $user }
              ],
              text: {
                format: {
                  type: "json_schema",
                  name: "orchestrator_packet",
                  strict: true,
                  schema: $schema
                }
              }
            }' > /tmp/openai_orchestrator_request.json

          # Call OpenAI
          curl -sS https://api.openai.com/v1/responses \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @/tmp/openai_orchestrator_request.json \
            > /tmp/openai_orchestrator_response.json

          # Surface API errors clearly
          if jq -e '.error' /tmp/openai_orchestrator_response.json >/dev/null; then
            echo "OpenAI API error:"
            jq -r '.error' /tmp/openai_orchestrator_response.json
            exit 1
          fi

          # Extract the model's output text (which will be the JSON object)
          ORCH_TEXT="$(jq -r '
            .output[]
            | select(.type=="message")
            | .content[]
            | select(.type=="output_text")
            | .text
          ' /tmp/openai_orchestrator_response.json)"

          if [ -z "${ORCH_TEXT:-}" ] || [ "${ORCH_TEXT}" = "null" ]; then
            echo "No output_text found in response:"
            jq . /tmp/openai_orchestrator_response.json
            exit 1
          fi

          # Validate it is JSON and compact it to a single line for safe step outputs
          echo "$ORCH_TEXT" | jq -e . > /tmp/orchestrator.json
          ORCH_COMPACT="$(cat /tmp/orchestrator.json | jq -c .)"

          # Emit outputs using heredoc format (handles special chars in JSON)
          DELIM="EOF_$(openssl rand -hex 8)"
          {
            echo "structured_output<<$DELIM"
            echo "$ORCH_COMPACT"
            echo "$DELIM"
            echo "result<<$DELIM"
            echo "$ORCH_COMPACT"
            echo "$DELIM"
          } >> "$GITHUB_OUTPUT"

      - name: Parse orchestrator output
        id: parse
        uses: actions/github-script@v7
        env:
          RAW_STRUCTURED: ${{ steps.orchestrator.outputs.structured_output }}
          RAW_RESULT: ${{ steps.orchestrator.outputs.result }}
        with:
          script: |
            const rawStructured = (process.env.RAW_STRUCTURED || '').trim();
            const rawResult = (process.env.RAW_RESULT || '').trim();
            const raw = rawStructured || rawResult;

            const tryParse = (s) => {
              try { return JSON.parse(s); } catch { return null; }
            };

            // 1) Prefer the action's structured output (should already be clean JSON)
            let parsed = tryParse(raw);

            // 2) Defensive fallback: strip wrappers and extract first JSON object
            if (!parsed) {
              const cleaned = raw
                .replace(/<thinking[\s\S]*?<\/thinking>/gi, "")
                .replace(/<analysis[\s\S]*?<\/analysis>/gi, "")
                .replace(/```(?:json)?/gi, "")
                .replace(/```/g, "")
                .trim();

              const start = cleaned.indexOf("{");
              const end = cleaned.lastIndexOf("}");
              if (start !== -1 && end !== -1 && end > start) {
                parsed = tryParse(cleaned.slice(start, end + 1));
              }
            }

            if (!parsed) {
              throw new Error("Could not find JSON object in orchestrator output.");
            }

            if (!parsed?.delegation || typeof parsed.issue_context !== "string") {
              console.log("Parsed object:", parsed);
              throw new Error("Parsed JSON missing required fields (issue_context, delegation).");
            }

            const d = parsed.delegation;

            core.setOutput("activate_documentation_sheriff", String(!!d.documentation_sheriff?.activate));
            core.setOutput("activate_infrastructure_engineer", String(!!d.infrastructure_engineer?.activate));
            core.setOutput("activate_product_owner", String(!!d.product_owner?.activate));
            core.setOutput("activate_project_manager", String(!!d.project_manager?.activate));
            core.setOutput("activate_security_engineer", String(!!d.security_engineer?.activate));
            core.setOutput("activate_software_engineer", String(!!d.software_engineer?.activate));
            core.setOutput("activate_tech_lead", String(!!d.tech_lead?.activate));
            core.setOutput("activate_test_engineer", String(!!d.test_engineer?.activate));
            core.setOutput("activate_ux_designer", String(!!d.ux_designer?.activate));
            core.setOutput("work_branch", parsed.branch?.name || "");

            core.setOutput("issue_context", parsed.issue_context);
            core.setOutput("delegation", JSON.stringify(d));
            core.setOutput("agent_prompts", JSON.stringify(d));

      - name: Create and push work branch (seed artifacts live here)
        id: work_branch
        shell: bash
        run: |
          set -euo pipefail

          BRANCH="${{ steps.parse.outputs.work_branch }}"
          if [ -z "${BRANCH:-}" ]; then
            echo "No work_branch provided by orchestrator."
            exit 1
          fi

          # Create branch from origin/main
          git fetch origin main
          git checkout -B "$BRANCH" origin/main

          # Create issue context file on the work branch
          mkdir -p working/issues
          SANITIZED_TITLE="$(echo "${{ steps.issue.outputs.title }}" | sed 's/[<>:"|?*\/\\]/_/g')"
          ISSUE_FILE="working/issues/${{ steps.issue.outputs.number }} ${SANITIZED_TITLE}.md"

          mkdir -p docs/adr docs/research

          if [ ! -f "$ISSUE_FILE" ]; then
            cat << EOF > "$ISSUE_FILE"
          # Issue #${{ steps.issue.outputs.number }}: ${{ steps.issue.outputs.title }}

          **Author:** ${{ steps.issue.outputs.author }}
          **Created:** ${{ steps.issue.outputs.created_at }}
          **Labels:** ${{ steps.issue.outputs.labels }}

          ## Original Description

          ${{ steps.issue.outputs.body }}

          ---

          ## Pre-Planning Context

          _This section will be populated by pre-work agents._

          ### Documentation Context
          _Pending documentation-sheriff (pre)_

          ### Infrastructure Context
          _Pending infrastructure-engineer (pre)_

          ### Security Context
          _Pending security-engineer (pre)_

          ---

          ## Planning Decisions

          _This section will be populated by planning agents._

          ### Product Requirements
          _Pending product-owner_

          ### UX Design Notes
          _Pending ux-designer_

          ### Technical Approach
          _Pending tech-lead_

          ---

          ## Implementation Notes

          _This section will be populated during development._

          ---

          ## Post-Work Validation

          _This section will be populated by post-work agents._

          EOF
          fi

          echo "issue_file=$ISSUE_FILE" >> "$GITHUB_OUTPUT"

          # Commit whatever the orchestrator seeded (docs + working/issues file)
          git add docs/ working/issues || true

          # Helper function for robust push with retry
          push_with_retry() {
            local max_retries=3
            local retry_delay=2
            
            for attempt in $(seq 1 $max_retries); do
              echo "Push attempt $attempt of $max_retries..."
              
              # For initial branch creation, use force-with-lease to handle re-runs
              if git push -u --force-with-lease origin "$BRANCH" 2>&1; then
                echo "Push succeeded on attempt $attempt"
                return 0
              fi
              
              if [ "$attempt" -eq "$max_retries" ]; then
                echo "ERROR: Push failed after $max_retries attempts"
                return 1
              fi
              
              echo "Push failed, retrying in ${retry_delay}s..."
              sleep "$retry_delay"
              retry_delay=$((retry_delay * 2))
            done
          }

          if git diff --cached --quiet; then
            echo "No seeded changes to commit (branch will still be created)."
            # still push branch so agents can check it out
            push_with_retry
            exit 0
          fi

          git commit -m "chore: seed issue context for #${{ steps.issue.outputs.number }}"
          push_with_retry

      - name: Write orchestrator packet (artifact)
        env:
          ORCH_JSON: ${{ steps.orchestrator.outputs.structured_output }}
        run: |
          set -euo pipefail
          mkdir -p .orchestrator
          # Write exactly what the action produced
          printf "%s" "${ORCH_JSON}" > .orchestrator/orchestrator.json

      - name: Upload orchestrator packet
        uses: actions/upload-artifact@v4
        with:
          name: orchestrator-${{ steps.issue.outputs.number }}
          path: .orchestrator/orchestrator.json
          retention-days: 1

  # ============================================================================
  # RESUME MODE: Inject orchestrator state from checkpoint
  # ============================================================================
  resume-orchestrate:
    name: Resume Orchestrator State
    runs-on: ubuntu-latest
    if: inputs.resume_mode == true
    outputs:
      delegation: ${{ steps.inject.outputs.delegation }}
      activate_documentation_sheriff: ${{ steps.inject.outputs.activate_documentation_sheriff }}
      activate_infrastructure_engineer: ${{ steps.inject.outputs.activate_infrastructure_engineer }}
      activate_product_owner: ${{ steps.inject.outputs.activate_product_owner }}
      activate_project_manager: ${{ steps.inject.outputs.activate_project_manager }}
      activate_security_engineer: ${{ steps.inject.outputs.activate_security_engineer }}
      activate_software_engineer: ${{ steps.inject.outputs.activate_software_engineer }}
      activate_tech_lead: ${{ steps.inject.outputs.activate_tech_lead }}
      activate_test_engineer: ${{ steps.inject.outputs.activate_test_engineer }}
      activate_ux_designer: ${{ steps.inject.outputs.activate_ux_designer }}
      issue_context: ${{ steps.inject.outputs.issue_context }}
      agent_prompts: ${{ steps.inject.outputs.agent_prompts }}
      issue_number: ${{ inputs.issue_number }}
      issue_file: ${{ steps.inject.outputs.issue_file }}
      work_branch: ${{ steps.inject.outputs.work_branch }}
      is_hotfix: ${{ steps.inject.outputs.is_hotfix }}
      # Resume-specific outputs
      resume_from_agent: ${{ inputs.resume_from_agent }}
      resume_from_phase: ${{ inputs.resume_from_phase }}
      clarification_response: ${{ inputs.clarification_response }}
      resume_planning_context: ${{ inputs.resume_planning_context }}
    steps:
      - name: Inject orchestrator state from inputs
        id: inject
        uses: actions/github-script@v7
        env:
          ORCHESTRATOR_STATE: ${{ inputs.orchestrator_state }}
        with:
          script: |
            const stateJson = process.env.ORCHESTRATOR_STATE || '{}';
            let state;
            try {
              state = JSON.parse(stateJson);
            } catch (e) {
              core.setFailed(`Failed to parse orchestrator_state: ${e.message}`);
              return;
            }

            // Output all the orchestrator state fields
            core.setOutput('activate_documentation_sheriff', state.activate_documentation_sheriff || 'false');
            core.setOutput('activate_infrastructure_engineer', state.activate_infrastructure_engineer || 'false');
            core.setOutput('activate_product_owner', state.activate_product_owner || 'false');
            core.setOutput('activate_project_manager', state.activate_project_manager || 'false');
            core.setOutput('activate_security_engineer', state.activate_security_engineer || 'false');
            core.setOutput('activate_software_engineer', state.activate_software_engineer || 'false');
            core.setOutput('activate_tech_lead', state.activate_tech_lead || 'false');
            core.setOutput('activate_test_engineer', state.activate_test_engineer || 'false');
            core.setOutput('activate_ux_designer', state.activate_ux_designer || 'false');
            core.setOutput('issue_context', state.issue_context || '');
            core.setOutput('agent_prompts', state.agent_prompts || '{}');
            core.setOutput('work_branch', state.work_branch || '');
            core.setOutput('issue_file', state.issue_file || '');
            core.setOutput('is_hotfix', state.is_hotfix || 'false');
            core.setOutput('delegation', state.delegation || '{}');

            console.log('Injected orchestrator state for resume mode');
            console.log(`Resume from: ${{ inputs.resume_from_agent }} (${{ inputs.resume_from_phase }})`);

      - name: Post resume notification
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ inputs.issue_number }};
            const agent = '${{ inputs.resume_from_agent }}';
            const phase = '${{ inputs.resume_from_phase }}';
            const checkpointId = '${{ inputs.resume_checkpoint_id }}';

            const body = [
              '## Pipeline Resumed',
              '',
              `The pipeline is resuming from the **${agent}** agent (${phase} phase) with your clarification response.`,
              '',
              `<!-- RESUME_CHECKPOINT: ${checkpointId} -->`
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body
            });

  # ============================================================================
  # CONSOLIDATED ORCHESTRATOR OUTPUT
  # This job consolidates outputs from either orchestrate or resume-orchestrate
  # All downstream jobs depend on this instead of directly on orchestrate
  # ============================================================================
  pipeline-config:
    name: Pipeline Configuration
    runs-on: ubuntu-latest
    needs: [orchestrate, resume-orchestrate]
    if: always() && (needs.orchestrate.result == 'success' || needs.resume-orchestrate.result == 'success')
    outputs:
      delegation: ${{ steps.consolidate.outputs.delegation }}
      activate_documentation_sheriff: ${{ steps.consolidate.outputs.activate_documentation_sheriff }}
      activate_infrastructure_engineer: ${{ steps.consolidate.outputs.activate_infrastructure_engineer }}
      activate_product_owner: ${{ steps.consolidate.outputs.activate_product_owner }}
      activate_project_manager: ${{ steps.consolidate.outputs.activate_project_manager }}
      activate_security_engineer: ${{ steps.consolidate.outputs.activate_security_engineer }}
      activate_software_engineer: ${{ steps.consolidate.outputs.activate_software_engineer }}
      activate_tech_lead: ${{ steps.consolidate.outputs.activate_tech_lead }}
      activate_test_engineer: ${{ steps.consolidate.outputs.activate_test_engineer }}
      activate_ux_designer: ${{ steps.consolidate.outputs.activate_ux_designer }}
      issue_context: ${{ steps.consolidate.outputs.issue_context }}
      agent_prompts: ${{ steps.consolidate.outputs.agent_prompts }}
      issue_number: ${{ steps.consolidate.outputs.issue_number }}
      issue_file: ${{ steps.consolidate.outputs.issue_file }}
      work_branch: ${{ steps.consolidate.outputs.work_branch }}
      is_hotfix: ${{ steps.consolidate.outputs.is_hotfix }}
      # Resume mode specific
      is_resume: ${{ steps.consolidate.outputs.is_resume }}
      resume_from_agent: ${{ steps.consolidate.outputs.resume_from_agent }}
      resume_from_phase: ${{ steps.consolidate.outputs.resume_from_phase }}
      clarification_response: ${{ steps.consolidate.outputs.clarification_response }}
      resume_planning_context: ${{ steps.consolidate.outputs.resume_planning_context }}
      # Resume skip flags - true means skip this agent (already ran before checkpoint)
      skip_pre_documentation: ${{ steps.resume_skip.outputs.skip_pre_documentation }}
      skip_pre_infrastructure: ${{ steps.resume_skip.outputs.skip_pre_infrastructure }}
      skip_pre_security: ${{ steps.resume_skip.outputs.skip_pre_security }}
      skip_planning_product: ${{ steps.resume_skip.outputs.skip_planning_product }}
      skip_planning_ux: ${{ steps.resume_skip.outputs.skip_planning_ux }}
      skip_planning_tech_lead: ${{ steps.resume_skip.outputs.skip_planning_tech_lead }}
      skip_development_software: ${{ steps.resume_skip.outputs.skip_development_software }}
      skip_development_infrastructure: ${{ steps.resume_skip.outputs.skip_development_infrastructure }}
      skip_post_test: ${{ steps.resume_skip.outputs.skip_post_test }}
      skip_post_security: ${{ steps.resume_skip.outputs.skip_post_security }}
      skip_post_documentation: ${{ steps.resume_skip.outputs.skip_post_documentation }}
      skip_project_manager: ${{ steps.resume_skip.outputs.skip_project_manager }}
      skip_code_review: ${{ steps.resume_skip.outputs.skip_code_review }}
    steps:
      - name: Consolidate orchestrator outputs
        id: consolidate
        shell: bash
        run: |
          # Determine which source to use
          if [ "${{ needs.resume-orchestrate.result }}" == "success" ]; then
            echo "Using resume-orchestrate outputs"
            echo "is_resume=true" >> "$GITHUB_OUTPUT"

            # Resume mode outputs
            echo "delegation=${{ needs.resume-orchestrate.outputs.delegation }}" >> "$GITHUB_OUTPUT"
            echo "activate_documentation_sheriff=${{ needs.resume-orchestrate.outputs.activate_documentation_sheriff }}" >> "$GITHUB_OUTPUT"
            echo "activate_infrastructure_engineer=${{ needs.resume-orchestrate.outputs.activate_infrastructure_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_product_owner=${{ needs.resume-orchestrate.outputs.activate_product_owner }}" >> "$GITHUB_OUTPUT"
            echo "activate_project_manager=${{ needs.resume-orchestrate.outputs.activate_project_manager }}" >> "$GITHUB_OUTPUT"
            echo "activate_security_engineer=${{ needs.resume-orchestrate.outputs.activate_security_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_software_engineer=${{ needs.resume-orchestrate.outputs.activate_software_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_tech_lead=${{ needs.resume-orchestrate.outputs.activate_tech_lead }}" >> "$GITHUB_OUTPUT"
            echo "activate_test_engineer=${{ needs.resume-orchestrate.outputs.activate_test_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_ux_designer=${{ needs.resume-orchestrate.outputs.activate_ux_designer }}" >> "$GITHUB_OUTPUT"
            echo "issue_context=${{ needs.resume-orchestrate.outputs.issue_context }}" >> "$GITHUB_OUTPUT"
            echo "agent_prompts=${{ needs.resume-orchestrate.outputs.agent_prompts }}" >> "$GITHUB_OUTPUT"
            echo "issue_number=${{ needs.resume-orchestrate.outputs.issue_number }}" >> "$GITHUB_OUTPUT"
            echo "issue_file=${{ needs.resume-orchestrate.outputs.issue_file }}" >> "$GITHUB_OUTPUT"
            echo "work_branch=${{ needs.resume-orchestrate.outputs.work_branch }}" >> "$GITHUB_OUTPUT"
            echo "is_hotfix=${{ needs.resume-orchestrate.outputs.is_hotfix }}" >> "$GITHUB_OUTPUT"
            echo "resume_from_agent=${{ needs.resume-orchestrate.outputs.resume_from_agent }}" >> "$GITHUB_OUTPUT"
            echo "resume_from_phase=${{ needs.resume-orchestrate.outputs.resume_from_phase }}" >> "$GITHUB_OUTPUT"
            echo "clarification_response=${{ needs.resume-orchestrate.outputs.clarification_response }}" >> "$GITHUB_OUTPUT"
            echo "resume_planning_context=${{ needs.resume-orchestrate.outputs.resume_planning_context }}" >> "$GITHUB_OUTPUT"
          else
            echo "Using orchestrate outputs"
            echo "is_resume=false" >> "$GITHUB_OUTPUT"

            # Normal mode outputs
            echo "delegation=${{ needs.orchestrate.outputs.delegation }}" >> "$GITHUB_OUTPUT"
            echo "activate_documentation_sheriff=${{ needs.orchestrate.outputs.activate_documentation_sheriff }}" >> "$GITHUB_OUTPUT"
            echo "activate_infrastructure_engineer=${{ needs.orchestrate.outputs.activate_infrastructure_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_product_owner=${{ needs.orchestrate.outputs.activate_product_owner }}" >> "$GITHUB_OUTPUT"
            echo "activate_project_manager=${{ needs.orchestrate.outputs.activate_project_manager }}" >> "$GITHUB_OUTPUT"
            echo "activate_security_engineer=${{ needs.orchestrate.outputs.activate_security_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_software_engineer=${{ needs.orchestrate.outputs.activate_software_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_tech_lead=${{ needs.orchestrate.outputs.activate_tech_lead }}" >> "$GITHUB_OUTPUT"
            echo "activate_test_engineer=${{ needs.orchestrate.outputs.activate_test_engineer }}" >> "$GITHUB_OUTPUT"
            echo "activate_ux_designer=${{ needs.orchestrate.outputs.activate_ux_designer }}" >> "$GITHUB_OUTPUT"
            echo "issue_context=${{ needs.orchestrate.outputs.issue_context }}" >> "$GITHUB_OUTPUT"
            echo "agent_prompts=${{ needs.orchestrate.outputs.agent_prompts }}" >> "$GITHUB_OUTPUT"
            echo "issue_number=${{ needs.orchestrate.outputs.issue_number }}" >> "$GITHUB_OUTPUT"
            echo "issue_file=${{ needs.orchestrate.outputs.issue_file }}" >> "$GITHUB_OUTPUT"
            echo "work_branch=${{ needs.orchestrate.outputs.work_branch }}" >> "$GITHUB_OUTPUT"
            echo "is_hotfix=${{ needs.orchestrate.outputs.is_hotfix }}" >> "$GITHUB_OUTPUT"
            echo "resume_from_agent=" >> "$GITHUB_OUTPUT"
            echo "resume_from_phase=" >> "$GITHUB_OUTPUT"
            echo "clarification_response=" >> "$GITHUB_OUTPUT"
            echo "resume_planning_context=" >> "$GITHUB_OUTPUT"
          fi

      - name: Calculate resume skip flags
        id: resume_skip
        shell: bash
        run: |
          # Pipeline order (index determines if agent should be skipped in resume mode)
          # Agents with index < resume_index should be skipped (already ran)
          # Agents with index >= resume_index should run (resume point and after)
          declare -A AGENT_ORDER=(
            ["documentation-sheriff:pre"]=1
            ["infrastructure-engineer:pre"]=2
            ["security-engineer:pre"]=3
            ["product-owner:main"]=4
            ["ux-designer:main"]=5
            ["tech-lead:main"]=6
            ["software-engineer:main"]=7
            ["infrastructure-engineer:main"]=8
            ["test-engineer:post"]=9
            ["security-engineer:post"]=10
            ["documentation-sheriff:post"]=11
            ["project-manager:post"]=12
            ["code-reviewer:review"]=13
          )

          IS_RESUME="${{ steps.consolidate.outputs.is_resume }}"
          RESUME_AGENT="${{ steps.consolidate.outputs.resume_from_agent }}"
          RESUME_PHASE="${{ steps.consolidate.outputs.resume_from_phase }}"

          if [ "$IS_RESUME" != "true" ]; then
            # Not in resume mode - don't skip anything
            echo "skip_pre_documentation=false" >> "$GITHUB_OUTPUT"
            echo "skip_pre_infrastructure=false" >> "$GITHUB_OUTPUT"
            echo "skip_pre_security=false" >> "$GITHUB_OUTPUT"
            echo "skip_planning_product=false" >> "$GITHUB_OUTPUT"
            echo "skip_planning_ux=false" >> "$GITHUB_OUTPUT"
            echo "skip_planning_tech_lead=false" >> "$GITHUB_OUTPUT"
            echo "skip_development_software=false" >> "$GITHUB_OUTPUT"
            echo "skip_development_infrastructure=false" >> "$GITHUB_OUTPUT"
            echo "skip_post_test=false" >> "$GITHUB_OUTPUT"
            echo "skip_post_security=false" >> "$GITHUB_OUTPUT"
            echo "skip_post_documentation=false" >> "$GITHUB_OUTPUT"
            echo "skip_project_manager=false" >> "$GITHUB_OUTPUT"
            echo "skip_code_review=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Get the resume point index
          RESUME_KEY="${RESUME_AGENT}:${RESUME_PHASE}"
          RESUME_INDEX="${AGENT_ORDER[$RESUME_KEY]:-0}"

          echo "Resume from: $RESUME_KEY (index: $RESUME_INDEX)"

          # For each agent, check if its index < resume_index (should skip)
          # skip_X=true means the agent already ran before the checkpoint

          check_skip() {
            local key="$1"
            local idx="${AGENT_ORDER[$key]:-0}"
            if [ "$idx" -lt "$RESUME_INDEX" ]; then
              echo "true"
            else
              echo "false"
            fi
          }

          echo "skip_pre_documentation=$(check_skip 'documentation-sheriff:pre')" >> "$GITHUB_OUTPUT"
          echo "skip_pre_infrastructure=$(check_skip 'infrastructure-engineer:pre')" >> "$GITHUB_OUTPUT"
          echo "skip_pre_security=$(check_skip 'security-engineer:pre')" >> "$GITHUB_OUTPUT"
          echo "skip_planning_product=$(check_skip 'product-owner:main')" >> "$GITHUB_OUTPUT"
          echo "skip_planning_ux=$(check_skip 'ux-designer:main')" >> "$GITHUB_OUTPUT"
          echo "skip_planning_tech_lead=$(check_skip 'tech-lead:main')" >> "$GITHUB_OUTPUT"
          echo "skip_development_software=$(check_skip 'software-engineer:main')" >> "$GITHUB_OUTPUT"
          echo "skip_development_infrastructure=$(check_skip 'infrastructure-engineer:main')" >> "$GITHUB_OUTPUT"
          echo "skip_post_test=$(check_skip 'test-engineer:post')" >> "$GITHUB_OUTPUT"
          echo "skip_post_security=$(check_skip 'security-engineer:post')" >> "$GITHUB_OUTPUT"
          echo "skip_post_documentation=$(check_skip 'documentation-sheriff:post')" >> "$GITHUB_OUTPUT"
          echo "skip_project_manager=$(check_skip 'project-manager:post')" >> "$GITHUB_OUTPUT"
          echo "skip_code_review=$(check_skip 'code-reviewer:review')" >> "$GITHUB_OUTPUT"

          echo "Calculated skip flags based on resume from index $RESUME_INDEX"

  # ============================================================================
  # HOTFIX MODE NOTIFICATION
  # ============================================================================
  hotfix-notify:
    name: Notify - Hotfix Mode
    needs: pipeline-config
    if: needs.pipeline-config.outputs.is_hotfix == 'true'
    uses: ./.github/workflows/discord-gpt-message.yml
    with:
      webhook_username: "Alex - Dev"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=AlexDev1"
      prompt: |
        ðŸš¨ hotfix triggered for #${{ needs.pipeline-config.outputs.issue_number }}

        fast-tracking - skipping planning phase, going straight to implementation

        context: ${{ needs.pipeline-config.outputs.issue_context }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  # ============================================================================
  # STAGE 2: pre_WORK AGENTS
  # ============================================================================
  pre_documentation_notify:
    name: Notify - Documentation Sheriff (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config]
    if: |
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_documentation_sheriff == 'true'
    with:
      webhook_username: "Riley - Docs"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=RileyDocs1"
      prompt: |
        picking up issue #${{ needs.pipeline-config.outputs.issue_number }}, checking what docs we have that might be relevant

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).documentation_sheriff.prompt }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  pre_documentation:
    name: Documentation Sheriff (Pre)
    needs: pipeline-config
    # Skip if: not activated OR flagged to skip in resume mode (already ran before checkpoint)
    if: |
      needs.pipeline-config.outputs.activate_documentation_sheriff == 'true' &&
      needs.pipeline-config.outputs.skip_pre_documentation != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: documentation-sheriff
      phase: pre
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  pre_infrastructure_notify:
    name: Notify - Infrastructure Engineer (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config, pre_documentation]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_infrastructure_engineer == 'true' &&
      (needs.pre_documentation.result == 'success' || needs.pre_documentation.result == 'skipped')
    with:
      webhook_username: "Sam - Infra"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=SamInfra1"
      prompt: |
        picking up #${{ needs.pipeline-config.outputs.issue_number }}, gonna scope out infra requirements

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).infrastructure_engineer.prompt }}
        docs notes: ${{ needs.pre_documentation.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  pre_infrastructure:
    name: Infrastructure Engineer (Pre)
    needs: pipeline-config
    # Skip if: not activated OR flagged to skip in resume mode (already ran before checkpoint)
    if: |
      needs.pipeline-config.outputs.activate_infrastructure_engineer == 'true' &&
      needs.pipeline-config.outputs.skip_pre_infrastructure != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: infrastructure-engineer
      phase: pre
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  pre_security_notify:
    name: Notify - Security Engineer (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config, pre_documentation, pre_infrastructure]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_security_engineer == 'true' &&
      (needs.pre_documentation.result == 'success' || needs.pre_documentation.result == 'skipped') &&
      (needs.pre_infrastructure.result == 'success' || needs.pre_infrastructure.result == 'skipped')
    with:
      webhook_username: "Casey - Security"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=CaseySec1"
      prompt: |
        looking at #${{ needs.pipeline-config.outputs.issue_number }} from a security angle now

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).security_engineer.prompt }}
        docs notes: ${{ needs.pre_documentation.outputs.result || 'n/a' }}
        infra notes: ${{ needs.pre_infrastructure.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  pre_security:
    name: Security Engineer (Pre)
    needs: pipeline-config
    # Skip if: not activated OR flagged to skip in resume mode (already ran before checkpoint)
    if: |
      needs.pipeline-config.outputs.activate_security_engineer == 'true' &&
      needs.pipeline-config.outputs.skip_pre_security != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: security-engineer
      phase: pre
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  # ============================================================================
  # STAGE 3: PLANNING AGENTS
  # ============================================================================
  pre_product_owner_notify:
    name: Notify - Product Owner (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs:
      [pipeline-config, pre_documentation, pre_infrastructure, pre_security]
    # Skip in hotfix mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.is_hotfix != 'true' &&
      needs.pipeline-config.outputs.activate_product_owner == 'true' &&
      (needs.pre_documentation.result == 'success' || needs.pre_documentation.result == 'skipped') &&
      (needs.pre_infrastructure.result == 'success' || needs.pre_infrastructure.result == 'skipped') &&
      (needs.pre_security.result == 'success' || needs.pre_security.result == 'skipped')
    with:
      webhook_username: "Morgan - Product"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=MorganPO1"
      prompt: |
        reviewing product requirements for #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).product_owner.prompt }}
        docs notes: ${{ needs.pre_documentation.outputs.result || 'n/a' }}
        infra notes: ${{ needs.pre_infrastructure.outputs.result || 'n/a' }}
        security notes: ${{ needs.pre_security.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  planning_product:
    name: Product Owner
    needs:
      [pipeline-config, pre_documentation, pre_infrastructure, pre_security]
    # Skip if: hotfix mode, not activated, or flagged to skip in resume mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.is_hotfix != 'true' &&
      needs.pipeline-config.outputs.activate_product_owner == 'true' &&
      needs.pipeline-config.outputs.skip_planning_product != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: product-owner
      phase: main
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  pre_ux_designer_notify:
    name: Notify - UX Designer (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs:
      [
        pipeline-config,
        pre_documentation,
        pre_infrastructure,
        pre_security,
        planning_product,
      ]
    # Skip in hotfix mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.is_hotfix != 'true' &&
      needs.pipeline-config.outputs.activate_ux_designer == 'true' &&
      (needs.planning_product.result == 'success' || needs.planning_product.result == 'skipped')
    with:
      webhook_username: "Drew - UX"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=DrewUX1"
      prompt: |
        thinking through ux for #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).ux_designer.prompt }}
        product notes: ${{ needs.planning_product.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  planning_ux:
    name: UX Designer
    needs:
      [pipeline-config, pre_documentation, pre_infrastructure, pre_security]
    # Skip if: hotfix mode, not activated, or flagged to skip in resume mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.is_hotfix != 'true' &&
      needs.pipeline-config.outputs.activate_ux_designer == 'true' &&
      needs.pipeline-config.outputs.skip_planning_ux != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: ux-designer
      phase: main
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  pre_tech_lead_notify:
    name: Notify - Tech Lead (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs:
      [
        pipeline-config,
        pre_documentation,
        pre_infrastructure,
        pre_security,
        planning_product,
        planning_ux,
      ]
    # Skip in hotfix mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.is_hotfix != 'true' &&
      needs.pipeline-config.outputs.activate_tech_lead == 'true' &&
      (needs.planning_product.result == 'success' || needs.planning_product.result == 'skipped') &&
      (needs.planning_ux.result == 'success' || needs.planning_ux.result == 'skipped')
    with:
      webhook_username: "Taylor - Lead"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=TaylorLead1"
      prompt: |
        mapping out the architecture for #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).tech_lead.prompt }}
        product notes: ${{ needs.planning_product.outputs.result || 'n/a' }}
        ux notes: ${{ needs.planning_ux.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  planning_tech_lead:
    name: Tech Lead
    needs:
      [pipeline-config, pre_documentation, pre_infrastructure, pre_security]
    # Skip if: hotfix mode, not activated, or flagged to skip in resume mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.is_hotfix != 'true' &&
      needs.pipeline-config.outputs.activate_tech_lead == 'true' &&
      needs.pipeline-config.outputs.skip_planning_tech_lead != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: tech-lead
      phase: main
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  # ============================================================================
  # STAGE 4: DEVELOPMENT
  # ============================================================================
  pre_software_engineer_notify:
    name: Notify - Software Engineer (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs:
      [
        pipeline-config,
        pre_documentation,
        pre_infrastructure,
        pre_security,
        planning_product,
        planning_ux,
        planning_tech_lead,
      ]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_software_engineer == 'true' &&
      (needs.planning_product.result == 'success' || needs.planning_product.result == 'skipped') &&
      (needs.planning_ux.result == 'success' || needs.planning_ux.result == 'skipped') &&
      (needs.planning_tech_lead.result == 'success' || needs.planning_tech_lead.result == 'skipped')
    with:
      webhook_username: "Alex - Dev"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=AlexDev1"
      prompt: |
        starting implementation on #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).software_engineer.prompt }}
        product notes: ${{ needs.planning_product.outputs.result || 'n/a' }}
        ux notes: ${{ needs.planning_ux.outputs.result || 'n/a' }}
        tech lead notes: ${{ needs.planning_tech_lead.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  development_software:
    name: Software Engineer
    needs: [pipeline-config, planning_product, planning_ux, planning_tech_lead]
    # Skip if: not activated, flagged to skip in resume mode, or (not hotfix and planning failed)
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_software_engineer == 'true' &&
      needs.pipeline-config.outputs.skip_development_software != 'true' &&
      (
        needs.pipeline-config.outputs.is_hotfix == 'true' ||
        (
          (needs.planning_product.result == 'success' || needs.planning_product.result == 'skipped') &&
          (needs.planning_ux.result == 'success' || needs.planning_ux.result == 'skipped') &&
          (needs.planning_tech_lead.result == 'success' || needs.planning_tech_lead.result == 'skipped')
        )
      )
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: software-engineer
      phase: main
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
      planning_context: >-
        Product Owner: ${{ needs.planning_product.outputs.result || 'Not activated' }}

        UX Designer: ${{ needs.planning_ux.outputs.result || 'Not activated' }}

        Tech Lead: ${{ needs.planning_tech_lead.outputs.result || 'Not activated' }}
    secrets: inherit

  pre_test-engineer_notify:
    name: Notify - Test Engineer (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config, development_software, development_infrastructure]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_test_engineer == 'true' &&
      (needs.development_software.result == 'success' || needs.development_infrastructure.result == 'success')
    with:
      webhook_username: "Jamie - QA"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=JamieQA1"
      prompt: |
        dev finished up on #${{ needs.pipeline-config.outputs.issue_number }}, running tests now

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).test_engineer.prompt }}
        dev notes: ${{ needs.development_software.outputs.result || 'n/a' }}
        infra notes: ${{ needs.development_infrastructure.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  development_infrastructure:
    name: Infrastructure Engineer (Main)
    needs: [pipeline-config, planning_tech_lead]
    # Skip if: not activated or flagged to skip in resume mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_infrastructure_engineer == 'true' &&
      needs.pipeline-config.outputs.skip_development_infrastructure != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: infrastructure-engineer
      phase: main
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
      planning_context: |
        Tech Lead: ${{ needs.planning_tech_lead.outputs.result || 'Not activated' }}
    secrets: inherit

  # ============================================================================
  # STAGE 5: post_WORK AGENTS
  # ============================================================================
  post_infrastructure_notify:
    name: Notify - Infrastructure Engineer (Post)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config, development_software, development_infrastructure]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_infrastructure_engineer == 'true' &&
      (needs.development_infrastructure.result == 'success')
    with:
      webhook_username: "Sam - Infra"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=SamInfra1"
      prompt: |
        validating infra changes for #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).infrastructure_engineer.prompt }}
        dev notes: ${{ needs.development_software.outputs.result || 'n/a' }}
        infra notes: ${{ needs.development_infrastructure.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  post_test:
    name: Test Engineer
    needs: [pipeline-config, development_software, development_infrastructure]
    # Skip if: not activated, flagged to skip in resume mode, or no dev work succeeded
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_test_engineer == 'true' &&
      needs.pipeline-config.outputs.skip_post_test != 'true' &&
      (needs.development_software.result == 'success' || needs.development_infrastructure.result == 'success')
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: test-engineer
      phase: post
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  post_security_notify:
    name: Notify - Security Engineer (Post)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs:
      [
        pipeline-config,
        development_software,
        development_infrastructure,
        post_test,
      ]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_security_engineer == 'true' &&
      (needs.development_software.result == 'success' || needs.development_infrastructure.result == 'success') &&
      (needs.post_test.result == 'success' || needs.post_test.result == 'skipped')
    with:
      webhook_username: "Casey - Security"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=CaseySec1"
      prompt: |
        running security validation on #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).security_engineer.prompt }}
        dev notes: ${{ needs.development_software.outputs.result || 'n/a' }}
        infra notes: ${{ needs.development_infrastructure.outputs.result || 'n/a' }}
        test notes: ${{ needs.post_test.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  post_security:
    name: Security Engineer (Post)
    needs: [pipeline-config, development_software, development_infrastructure]
    # Skip if: not activated, flagged to skip in resume mode, or no dev work succeeded
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_security_engineer == 'true' &&
      needs.pipeline-config.outputs.skip_post_security != 'true' &&
      (needs.development_software.result == 'success' || needs.development_infrastructure.result == 'success')
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: security-engineer
      phase: post
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  post_documentation_notify:
    name: Notify - Documentation Sheriff (Post)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs:
      [
        pipeline-config,
        development_software,
        development_infrastructure,
        post_test,
        post_security,
      ]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_documentation_sheriff == 'true' &&
      (needs.development_software.result == 'success' || needs.development_infrastructure.result == 'success') &&
      (needs.post_test.result == 'success' || needs.post_test.result == 'skipped') &&
      (needs.post_security.result == 'success' || needs.post_security.result == 'skipped')
    with:
      webhook_username: "Riley - Docs"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=RileyDocs1"
      prompt: |
        updating docs for #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).documentation_sheriff.prompt }}
        dev notes: ${{ needs.development_software.outputs.result || 'n/a' }}
        infra notes: ${{ needs.development_infrastructure.outputs.result || 'n/a' }}
        test notes: ${{ needs.post_test.outputs.result || 'n/a' }}
        security notes: ${{ needs.post_security.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  post_documentation:
    name: Documentation Sheriff (Post)
    needs:
      [
        pipeline-config,
        development_software,
        development_infrastructure,
        post_test,
      ]
    # Skip if: not activated, flagged to skip in resume mode, or no dev work succeeded
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_documentation_sheriff == 'true' &&
      needs.pipeline-config.outputs.skip_post_documentation != 'true' &&
      (needs.development_software.result == 'success' || needs.development_infrastructure.result == 'success')
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: documentation-sheriff
      phase: post
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  # ============================================================================
  # STAGE 6: PROJECT MANAGEMENT
  # ============================================================================
  post_project-manager-notify:
    name: Notify - Project Manager (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config, post_test, post_security, post_documentation]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_project_manager == 'true' &&
      (needs.post_test.result == 'success' || needs.post_test.result == 'skipped') &&
      (needs.post_security.result == 'success' || needs.post_security.result == 'skipped') &&
      (needs.post_documentation.result == 'success' || needs.post_documentation.result == 'skipped')
    with:
      webhook_username: "Jordan - PM"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=JordanPM1"
      prompt: |
        wrapping up project tracking for #${{ needs.pipeline-config.outputs.issue_number }}

        my task: ${{ fromJson(needs.pipeline-config.outputs.agent_prompts).project_manager.prompt }}
        test notes: ${{ needs.post_test.outputs.result || 'n/a' }}
        security notes: ${{ needs.post_security.outputs.result || 'n/a' }}
        docs notes: ${{ needs.post_documentation.outputs.result || 'n/a' }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  project-management:
    name: Project Manager
    needs: [pipeline-config, post_test, post_security, post_documentation]
    # Skip if: not activated or flagged to skip in resume mode
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.pipeline-config.outputs.activate_project_manager == 'true' &&
      needs.pipeline-config.outputs.skip_project_manager != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: project-manager
      phase: post
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  # ============================================================================
  # STAGE 7: CREATE PR
  # ============================================================================
  create-pr-notify:
    name: Notify - Create PR (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config, create-pr]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.create-pr.result == 'success' &&
      needs.create-pr.outputs.has_changes == 'true'
    with:
      webhook_username: "Jordan - PM"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=JordanPM1"
      prompt: |
        <@${{ vars.DISCORD_TEAM_LEAD_USER_ID }}> PR ready for review!

        pr is up for #${{ needs.pipeline-config.outputs.issue_number }}
        url: ${{ needs.create-pr.outputs.pr_url }}
        context: ${{ needs.pipeline-config.outputs.issue_context }}
        branch: ${{ needs.pipeline-config.outputs.work_branch }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_PR_WEBHOOK_URL }}

  create-pr:
    name: Create Pull Request
    needs:
      [
        pipeline-config,
        planning_product,
        planning_ux,
        planning_tech_lead,
        development_software,
        development_infrastructure,
        post_test,
        post_security,
        post_documentation,
        project-management,
      ]
    if: |
      always() &&
      needs.pipeline-config.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps['create-pr'].outputs.pr_number }}
      pr_url: ${{ steps['create-pr'].outputs.pr_url }}
      has_changes: ${{ steps.changes.outputs.has_changes }}
    steps:
      - name: Checkout work branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          ref: ${{ needs.pipeline-config.outputs.work_branch }}

      - name: Get issue number
        id: issue
        run: |
          echo "number=${{ needs.pipeline-config.outputs.issue_number }}" >> $GITHUB_OUTPUT

      - name: Check for changes vs main
        id: changes
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin main

          if git diff --quiet origin/main..HEAD; then
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            echo "No changes detected vs origin/main"
          else
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            echo "Changes detected vs origin/main"
            git --no-pager status
            git --no-pager diff --stat origin/main..HEAD
          fi

      # Generate a comprehensive PR title and description using GPT-4o
      - name: Get issue details for PR generation
        id: issue_details
        if: steps.changes.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = ${{ steps.issue.outputs.number }};
            const { data: issue } = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            core.setOutput('labels', issue.labels.map(l => l.name).join(', '));

      - name: Collect git diff stats
        id: diff_stats
        if: steps.changes.outputs.has_changes == 'true'
        shell: bash
        run: |
          set -euo pipefail

          # Get diff stats summary
          DIFF_STAT=$(git --no-pager diff --stat origin/main..HEAD)
          DIFF_SHORTSTAT=$(git --no-pager diff --shortstat origin/main..HEAD)

          # Get list of changed files
          FILES_CHANGED=$(git --no-pager diff --name-only origin/main..HEAD | head -50)

          # Store outputs using heredoc for multi-line content
          DELIM="EOF_$(openssl rand -hex 8)"
          echo "diff_stat<<$DELIM" >> "$GITHUB_OUTPUT"
          echo "$DIFF_STAT" >> "$GITHUB_OUTPUT"
          echo "$DELIM" >> "$GITHUB_OUTPUT"

          echo "shortstat=$DIFF_SHORTSTAT" >> "$GITHUB_OUTPUT"

          echo "files_changed<<$DELIM" >> "$GITHUB_OUTPUT"
          echo "$FILES_CHANGED" >> "$GITHUB_OUTPUT"
          echo "$DELIM" >> "$GITHUB_OUTPUT"

      - name: Generate PR title and description with GPT-4o
        id: generate_pr
        if: steps.changes.outputs.has_changes == 'true'
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.number }}
          ISSUE_TITLE: ${{ steps.issue_details.outputs.title }}
          ISSUE_BODY: ${{ steps.issue_details.outputs.body }}
          ISSUE_LABELS: ${{ steps.issue_details.outputs.labels }}
          ISSUE_CONTEXT: ${{ needs.pipeline-config.outputs.issue_context }}
          PRODUCT_RESULT: ${{ needs.planning_product.outputs.result }}
          UX_RESULT: ${{ needs.planning_ux.outputs.result }}
          TECH_LEAD_RESULT: ${{ needs.planning_tech_lead.outputs.result }}
          SOFTWARE_RESULT: ${{ needs.development_software.outputs.result }}
          INFRA_RESULT: ${{ needs.development_infrastructure.outputs.result }}
          TEST_RESULT: ${{ needs.post_test.outputs.result }}
          SECURITY_RESULT: ${{ needs.post_security.outputs.result }}
          DOCS_RESULT: ${{ needs.post_documentation.outputs.result }}
          DIFF_SHORTSTAT: ${{ steps.diff_stats.outputs.shortstat }}
          FILES_CHANGED: ${{ steps.diff_stats.outputs.files_changed }}
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${OPENAI_API_KEY:-}" ]; then
            echo "OPENAI_API_KEY is missing. Falling back to default PR content."
            echo "pr_title=[Auto] Resolves #${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
            echo "pr_body=Automated PR for issue #${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build the system prompt
          SYSTEM_PROMPT=$(cat <<'EOF'
          You are a PR description generator. Your job is to create clear, informative PR titles and descriptions based on issue context and agent work summaries.

          Guidelines:
          - Title: Concise, action-oriented (max 72 chars). Format: "<type>: <description>" where type is feat/fix/chore/docs/refactor/test/ci
          - Description: Well-structured markdown with sections for Summary, Key Changes, and Testing (if applicable)
          - Focus on WHAT changed and WHY, not the process
          - Extract key information from agent summaries - they contain the actual work done
          - Include "Closes #<issue_number>" at the end
          EOF
          )

          # Build user prompt with all available context
          USER_PROMPT=$(cat <<EOF
          ## Issue
          #${ISSUE_NUMBER}: ${ISSUE_TITLE}
          Labels: ${ISSUE_LABELS:-None}

          ### Issue Description
          ${ISSUE_BODY:-No description provided}

          ## Orchestrator Context
          ${ISSUE_CONTEXT:-No context provided}

          ## Agent Work Summaries
          (Each agent output contains: summary, files_changed, commits_made, notes_for_next_agent)

          ### Product Owner
          ${PRODUCT_RESULT:-Not activated}

          ### UX Designer
          ${UX_RESULT:-Not activated}

          ### Tech Lead
          ${TECH_LEAD_RESULT:-Not activated}

          ### Software Engineer
          ${SOFTWARE_RESULT:-Not activated}

          ### Infrastructure Engineer
          ${INFRA_RESULT:-Not activated}

          ### Test Engineer
          ${TEST_RESULT:-Not activated}

          ### Security Engineer
          ${SECURITY_RESULT:-Not activated}

          ### Documentation Sheriff
          ${DOCS_RESULT:-Not activated}

          ## Git Changes
          ${DIFF_SHORTSTAT:-No changes}

          ### Files Changed
          ${FILES_CHANGED:-No files}

          ---
          Generate a PR title and comprehensive description based on the above context.
          EOF
          )

          # Define structured output schema
          SCHEMA_JSON=$(cat <<'EOF'
          {
            "type": "object",
            "additionalProperties": false,
            "required": ["title", "body"],
            "properties": {
              "title": { 
                "type": "string",
                "description": "Concise PR title (max 72 chars), format: <type>: <description>"
              },
              "body": { 
                "type": "string",
                "description": "Comprehensive PR description in markdown format"
              }
            }
          }
          EOF
          )

          # Build OpenAI API request
          jq -n \
            --arg model "gpt-4o-2024-08-06" \
            --arg system "$SYSTEM_PROMPT" \
            --arg user "$USER_PROMPT" \
            --argjson schema "$SCHEMA_JSON" \
            '{
              model: $model,
              store: false,
              temperature: 0.3,
              max_output_tokens: 2000,
              input: [
                { role: "system", content: $system },
                { role: "user", content: $user }
              ],
              text: {
                format: {
                  type: "json_schema",
                  name: "pr_content",
                  strict: true,
                  schema: $schema
                }
              }
            }' > /tmp/openai_pr_request.json

          # Call OpenAI API
          curl -sS https://api.openai.com/v1/responses \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @/tmp/openai_pr_request.json \
            > /tmp/openai_pr_response.json

          # Check for API errors
          if jq -e '.error' /tmp/openai_pr_response.json >/dev/null; then
            echo "OpenAI API error, falling back to default PR content:"
            jq -r '.error' /tmp/openai_pr_response.json
            echo "pr_title=[Auto] Resolves #${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
            echo "pr_body=Automated PR for issue #${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract the generated content
          PR_JSON="$(jq -r '
            .output[]
            | select(.type=="message")
            | .content[]
            | select(.type=="output_text")
            | .text
          ' /tmp/openai_pr_response.json)"

          if [ -z "${PR_JSON:-}" ] || [ "${PR_JSON}" = "null" ]; then
            echo "No output_text found in response, falling back to default:"
            jq . /tmp/openai_pr_response.json
            echo "pr_title=[Auto] Resolves #${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
            echo "pr_body=Automated PR for issue #${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Parse and output the title and body
          PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')
          PR_BODY=$(echo "$PR_JSON" | jq -r '.body')

          echo "Generated PR Title: $PR_TITLE"
          echo "pr_title=$PR_TITLE" >> "$GITHUB_OUTPUT"

          # Use heredoc for multi-line body
          DELIM="EOF_$(openssl rand -hex 8)"
          echo "pr_body<<$DELIM" >> "$GITHUB_OUTPUT"
          echo "$PR_BODY" >> "$GITHUB_OUTPUT"
          echo "$DELIM" >> "$GITHUB_OUTPUT"

      - name: Create Pull Request
        id: create-pr
        if: steps.changes.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        env:
          GENERATED_TITLE: ${{ steps.generate_pr.outputs.pr_title }}
          GENERATED_BODY: ${{ steps.generate_pr.outputs.pr_body }}
          AGENT_PROMPTS: ${{ needs.pipeline-config.outputs.agent_prompts }}
        with:
          github-token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          script: |
            const issueNumber = ${{ steps.issue.outputs.number }};
            const branchName = `${{ needs.pipeline-config.outputs.work_branch }}`;

            // Check if a PR already exists for this branch
            const { data: existingPRs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branchName}`,
              base: 'main',
              state: 'open'
            });

            if (existingPRs.length > 0) {
              // PR already exists, reuse it
              const existingPR = existingPRs[0];
              console.log(`PR #${existingPR.number} already exists for branch ${branchName}`);
              core.setOutput('pr_number', existingPR.number);
              core.setOutput('pr_url', existingPR.html_url);
              return;
            }

            // Use GPT-4o generated title and body, with fallbacks
            const generatedTitle = process.env.GENERATED_TITLE || `[Auto] Resolves #${issueNumber}`;
            const generatedBody = process.env.GENERATED_BODY || 'Automated PR for issue.';

            // Embed agent_prompts JSON for fix-review-feedback workflow to retrieve
            const agentPromptsJson = process.env.AGENT_PROMPTS || '{}';

            // Combine generated body with required metadata
            const prBody = [
              generatedBody,
              '',
              '---',
              '',
              `Closes #${issueNumber}`,
              '',
              '<!-- AGENT_PROMPTS_JSON',
              agentPromptsJson,
              '-->'
            ].join('\n');

            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: generatedTitle,
              body: prBody,
              head: branchName,
              base: 'main'
            });

            console.log(`Created PR #${pr.number}: ${generatedTitle}`);
            core.setOutput('pr_number', pr.number);
            core.setOutput('pr_url', pr.html_url);

  # ============================================================================
  # STAGE 8: CODE REVIEW
  # ============================================================================
  code-review-notify:
    name: Notify - Code Reviewer (Pre)
    uses: ./.github/workflows/discord-gpt-message.yml
    needs: [pipeline-config, create-pr]
    if: |
      always() &&
      needs.pipeline-config.result == 'success' &&
      needs.create-pr.result == 'success' &&
      needs.create-pr.outputs.pr_number != ''
    with:
      webhook_username: "Avery - Review"
      webhook_avatar_url: "https://api.dicebear.com/9.x/personas/png?seed=AveryReview1"
      prompt: |
        reviewing pr for #${{ needs.pipeline-config.outputs.issue_number }}

        context: ${{ needs.pipeline-config.outputs.issue_context }}
        pr: ${{ needs.create-pr.outputs.pr_url }}
    secrets:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}

  code-review:
    name: Code Reviewer
    needs: [pipeline-config, create-pr]
    # Skip if: no PR created, or flagged to skip in resume mode
    if: |
      always() &&
      needs['create-pr'].result == 'success' &&
      needs['create-pr'].outputs.pr_number != '' &&
      needs.pipeline-config.outputs.skip_code_review != 'true'
    uses: ./.github/workflows/agent-step.yml
    with:
      agent_name: code-reviewer
      phase: review
      issue_number: ${{ needs.pipeline-config.outputs.issue_number }}
      issue_context: ${{ needs.pipeline-config.outputs.issue_context }}
      agent_prompts: ${{ needs.pipeline-config.outputs.agent_prompts }}
      pr_number: ${{ needs['create-pr'].outputs.pr_number }}
      work_branch: ${{ needs.pipeline-config.outputs.work_branch }}
      is_resume: ${{ needs.pipeline-config.outputs.is_resume }}
      clarification_response: ${{ needs.pipeline-config.outputs.clarification_response }}
    secrets: inherit

  # ============================================================================
  # STAGE 8.5: COUNTING APPROVAL (github-actions[bot])
  # ============================================================================
  actions-approve:
    name: Approve PR (github-actions[bot])
    needs: [create-pr, code-review]
    if: |
      always() &&
      needs.create-pr.result == 'success' &&
      needs.create-pr.outputs.pr_number != ''
    runs-on: ubuntu-latest
    outputs:
      approved: ${{ steps.gate.outputs.approve }}
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Decide if we should approve
        id: gate
        shell: bash
        run: |
          set -euo pipefail

          REVIEW_TEXT='${{ needs.code-review.outputs.result }}'

          # Heuristic: only approve if the reviewer output looks like an approval.
          # Tweak these keywords to match what your code-review agent emits.
          if echo "$REVIEW_TEXT" | grep -qiE '\b(APPROVED|LGTM|SHIP IT)\b'; then
            echo "approve=true" >> "$GITHUB_OUTPUT"
          else
            echo "approve=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Submit approval review as github-actions[bot]
        if: steps.gate.outputs.approve == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }} # <-- this is github-actions[bot]
          script: |
            const prNumber = parseInt('${{ needs.create-pr.outputs.pr_number }}', 10);

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              event: "APPROVE",
              body: "Pull request was vetted by team and approved."
            });

            console.log(`Approved PR #${prNumber} as github-actions[bot]`);

      - name: Trigger fix-review-feedback on rejection
        if: steps.gate.outputs.approve == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          script: |
            const prNumber = parseInt('${{ needs.create-pr.outputs.pr_number }}', 10);

            console.log(`Code review rejected PR #${prNumber}, triggering fix-review-feedback workflow`);

            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'fix-review-feedback.yml',
              ref: 'main',
              inputs: {
                pr_number: String(prNumber)
              }
            });

            console.log(`Triggered fix-review-feedback for PR #${prNumber}`);

  # ============================================================================
  # STAGE 9: WRAP-UP
  # ============================================================================
  wrap-up:
    name: Wrap Up Session
    needs: [pipeline-config, code-review, create-pr]
    if: always() && needs.pipeline-config.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout work branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          ref: ${{ needs.pipeline-config.outputs.work_branch }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git fetch origin "${{ needs.pipeline-config.outputs.work_branch }}"
          git checkout -B "${{ needs.pipeline-config.outputs.work_branch }}" "origin/${{ needs.pipeline-config.outputs.work_branch }}"

      - name: Append to DEVLOG.md
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: >-
            --model claude-opus-4-5-20251101
            --max-turns 6000
          prompt: |
            You are the Pipeline Orchestrator wrapping up a session.

            ## Session Summary
            - Issue: #${{ needs.pipeline-config.outputs.issue_number }}
            - Context: ${{ needs.pipeline-config.outputs.issue_context }}
            ${{ needs['create-pr'].outputs.pr_url && format('- PR Created: {0}', needs['create-pr'].outputs.pr_url) || '' }}
            ${{ needs['code-review'].result && format('- Code Review Result: {0}', needs['code-review'].result) || '' }}
            ${{ needs['code-review'].outputs.result || '' }}

            ## Your Task
            1. Read the issue context file at working/issues/ for issue #${{ needs.pipeline-config.outputs.issue_number }}
            2. Grep DEVLOG.md for "## Session" to find the last session entry
            3. Append a new session entry to DEVLOG.md with:
               - Session timestamp
               - Issue number and title
               - Summary of what was accomplished
               - Agents that participated
               - Any notable decisions or changes
               - Link to PR if created
               - **Code Review Status** (APPROVED/REJECTED) - Include prominently if review occurred
            4. Commit the DEVLOG.md update

            Use the format:
            ```
            ## Session [YYYY-MM-DD HH:MM UTC]

            ### Issue #X: Title

            **Summary:** Brief description of work done

            **Agents Activated:**
            - agent-name: what they did

            **Key Decisions:**
            - Decision 1
            - Decision 2

            **PR:** #X or N/A

            ---
            ```

  # ============================================================================
  # STAGE 10: TRIGGER AUTO-MERGE
  # ============================================================================
  trigger-auto-merge:
    name: Trigger Auto-Merge
    needs: [pipeline-config, create-pr, actions-approve, wrap-up]
    if: |
      always() &&
      needs.create-pr.result == 'success' &&
      needs.create-pr.outputs.pr_number != '' &&
      needs.actions-approve.result == 'success' &&
      needs.actions-approve.outputs.approved == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger auto-merge workflow
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          script: |
            const prNumber = parseInt('${{ needs.create-pr.outputs.pr_number }}', 10);

            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'auto-merge.yml',
              ref: 'main',
              inputs: {
                pr_number: String(prNumber)
              }
            });

            console.log(`Triggered auto-merge workflow for PR #${prNumber}`);
