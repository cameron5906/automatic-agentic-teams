# Weekly Standup Summary
# Generates AI-powered weekly development summaries and posts to Discord
# See: docs/automation/weekly-standup.md

name: Weekly Standup Summary

on:
  schedule:
    # Friday 5 PM UTC (noon ET, 9 AM PT)
    - cron: "0 17 * * 5"
  workflow_dispatch:
    inputs:
      lookback_days:
        description: "Days to look back"
        required: false
        type: number
        default: 7
      additional_channels:
        description: "Also post to dev/product channels"
        required: false
        type: boolean
        default: false

env:
  DEFAULT_LOOKBACK_DAYS: 7

permissions:
  contents: write
  issues: read
  pull-requests: read
  actions: read

jobs:
  # ============================================================================
  # Collect development metrics from the past week
  # ============================================================================
  collect-metrics:
    name: Collect Development Metrics
    runs-on: ubuntu-latest
    outputs:
      issues_closed_count: ${{ steps.issues.outputs.count }}
      issues_closed_list: ${{ steps.issues.outputs.list }}
      prs_merged_count: ${{ steps.prs.outputs.count }}
      prs_merged_list: ${{ steps.prs.outputs.list }}
      agent_success_rate: ${{ steps.agents.outputs.success_rate }}
      fix_iterations_avg: ${{ steps.agents.outputs.fix_iterations_avg }}
      blockers: ${{ steps.blockers.outputs.list }}
      hotfixes_count: ${{ steps.hotfixes.outputs.count }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Calculate lookback date
        id: dates
        run: |
          LOOKBACK_DAYS="${{ inputs.lookback_days || env.DEFAULT_LOOKBACK_DAYS }}"
          SINCE_DATE=$(date -d "-${LOOKBACK_DAYS} days" -Iseconds)
          echo "since=$SINCE_DATE" >> "$GITHUB_OUTPUT"
          echo "lookback_days=$LOOKBACK_DAYS" >> "$GITHUB_OUTPUT"
          echo "Looking back $LOOKBACK_DAYS days from $SINCE_DATE"

      - name: Collect closed issues
        id: issues
        uses: actions/github-script@v7
        with:
          script: |
            const since = '${{ steps.dates.outputs.since }}';

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              since: since,
              per_page: 100
            });

            // Filter to actually closed in period (not just updated) and exclude PRs
            const sinceDate = new Date(since);
            const closedInPeriod = issues.filter(i => 
              !i.pull_request && 
              new Date(i.closed_at) >= sinceDate
            );

            console.log(`Found ${closedInPeriod.length} issues closed in period`);

            core.setOutput('count', closedInPeriod.length);
            core.setOutput('list', JSON.stringify(closedInPeriod.map(i => ({
              number: i.number,
              title: i.title,
              labels: i.labels.map(l => l.name)
            }))));

      - name: Collect merged PRs
        id: prs
        uses: actions/github-script@v7
        with:
          script: |
            const since = '${{ steps.dates.outputs.since }}';
            const sinceDate = new Date(since);

            // Get recently updated PRs (includes merged)
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });

            // Filter to merged in period
            const mergedInPeriod = prs.filter(pr => 
              pr.merged_at && new Date(pr.merged_at) >= sinceDate
            );

            console.log(`Found ${mergedInPeriod.length} PRs merged in period`);

            core.setOutput('count', mergedInPeriod.length);
            core.setOutput('list', JSON.stringify(mergedInPeriod.map(pr => ({
              number: pr.number,
              title: pr.title,
              author: pr.user.login,
              merged_at: pr.merged_at
            }))));

      - name: Calculate agent performance
        id: agents
        uses: actions/github-script@v7
        with:
          script: |
            const since = '${{ steps.dates.outputs.since }}';

            try {
              // Get workflow runs for issue-pipeline
              const { data: pipelineRuns } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'issue-pipeline.yml',
                created: `>=${since.split('T')[0]}`
              });
              
              // Get workflow runs for fix-review-feedback
              const { data: fixRuns } = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'fix-review-feedback.yml',
                created: `>=${since.split('T')[0]}`
              });
              
              const successCount = pipelineRuns.workflow_runs.filter(r => r.conclusion === 'success').length;
              const totalCount = pipelineRuns.workflow_runs.length;
              const successRate = totalCount > 0 ? Math.round((successCount / totalCount) * 100) : 0;
              
              // Estimate fix iterations from fix-review-feedback runs per pipeline run
              const fixIterationsAvg = pipelineRuns.workflow_runs.length > 0 
                ? (fixRuns.workflow_runs.length / pipelineRuns.workflow_runs.length).toFixed(1)
                : '0';
              
              console.log(`Pipeline success rate: ${successRate}%, avg fix iterations: ${fixIterationsAvg}`);
              
              core.setOutput('success_rate', successRate);
              core.setOutput('fix_iterations_avg', fixIterationsAvg);
            } catch (e) {
              console.log('Could not fetch workflow data:', e.message);
              core.setOutput('success_rate', 'N/A');
              core.setOutput('fix_iterations_avg', 'N/A');
            }

      - name: Identify blockers
        id: blockers
        uses: actions/github-script@v7
        with:
          script: |
            // Find open issues with blocking labels
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'blocked,needs-human-review',
              per_page: 50
            });

            console.log(`Found ${issues.length} blocking issues`);

            core.setOutput('list', JSON.stringify(issues.map(i => ({
              number: i.number,
              title: i.title,
              labels: i.labels.map(l => l.name)
            }))));

      - name: Count hotfixes
        id: hotfixes
        uses: actions/github-script@v7
        with:
          script: |
            const since = '${{ steps.dates.outputs.since }}';
            const sinceDate = new Date(since);

            // Get issues with hotfix label closed in period
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              labels: 'hotfix',
              since: since,
              per_page: 100
            });

            const closedInPeriod = issues.filter(i => 
              !i.pull_request && 
              new Date(i.closed_at) >= sinceDate
            );

            console.log(`Found ${closedInPeriod.length} hotfixes in period`);
            core.setOutput('count', closedInPeriod.length);

  # ============================================================================
  # Generate AI summary
  # ============================================================================
  generate-summary:
    name: Generate AI Summary
    needs: collect-metrics
    runs-on: ubuntu-latest
    outputs:
      summary: ${{ steps.generate.outputs.summary }}
    steps:
      - name: Generate summary (GPT-4o)
        id: generate
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          ISSUES_CLOSED: ${{ needs.collect-metrics.outputs.issues_closed_count }}
          ISSUES_LIST: ${{ needs.collect-metrics.outputs.issues_closed_list }}
          PRS_MERGED: ${{ needs.collect-metrics.outputs.prs_merged_count }}
          PRS_LIST: ${{ needs.collect-metrics.outputs.prs_merged_list }}
          AGENT_SUCCESS_RATE: ${{ needs.collect-metrics.outputs.agent_success_rate }}
          FIX_ITERATIONS: ${{ needs.collect-metrics.outputs.fix_iterations_avg }}
          BLOCKERS: ${{ needs.collect-metrics.outputs.blockers }}
          HOTFIXES: ${{ needs.collect-metrics.outputs.hotfixes_count }}
        shell: bash
        run: |
          set -euo pipefail

          SYSTEM_PROMPT="You write weekly dev team standup summaries. Be concise, casual. Highlight wins, call out blockers, and give a quick health check on the automation pipeline. Keep it under 500 words."

          USER_PROMPT=$(cat <<USERPROMPT
          Generate a weekly standup summary.
          Metrics: Issues closed: ${ISSUES_CLOSED}, PRs merged: ${PRS_MERGED}, Hotfixes: ${HOTFIXES}, Pipeline success rate: ${AGENT_SUCCESS_RATE}%, Avg fix iterations: ${FIX_ITERATIONS}
          Issues completed: ${ISSUES_LIST}
          PRs merged: ${PRS_LIST}
          Current blockers: ${BLOCKERS}
          Write a 3-4 paragraph summary covering what shipped, pipeline health, and any concerns.
          USERPROMPT
          )

          cat > /tmp/schema.json <<'SCHEMA'
          {"type":"object","additionalProperties":false,"required":["summary"],"properties":{"summary":{"type":"string"}}}
          SCHEMA

          jq -n \
            --arg model "gpt-4o-2024-08-06" \
            --arg system "$SYSTEM_PROMPT" \
            --arg user "$USER_PROMPT" \
            --slurpfile schema /tmp/schema.json \
            '{model:$model,store:false,temperature:0.5,max_output_tokens:1500,input:[{role:"system",content:$system},{role:"user",content:$user}],text:{format:{type:"json_schema",name:"standup_summary",strict:true,schema:$schema[0]}}}' \
            > /tmp/openai_request.json

          curl -sS https://api.openai.com/v1/responses \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -d @/tmp/openai_request.json \
            > /tmp/openai_response.json

          SUMMARY_JSON="$(jq -r '.output[] | select(.type=="message") | .content[] | select(.type=="output_text") | .text' /tmp/openai_response.json 2>/dev/null || echo '{}')"

          SUMMARY=$(echo "$SUMMARY_JSON" | jq -r '.summary // "No summary generated"')

          DELIM="EOF_$(openssl rand -hex 8)"
          echo "summary<<$DELIM" >> "$GITHUB_OUTPUT"
          echo "$SUMMARY" >> "$GITHUB_OUTPUT"
          echo "$DELIM" >> "$GITHUB_OUTPUT"

          echo "Summary generated successfully"

  # ============================================================================
  # Post to dedicated standup channel
  # ============================================================================
  post-to-standup-channel:
    name: Post to Standup Channel
    needs: [collect-metrics, generate-summary]
    runs-on: ubuntu-latest
    steps:
      - name: Post summary
        env:
          DISCORD_STANDUP_WEBHOOK_URL: ${{ secrets.DISCORD_STANDUP_WEBHOOK_URL }}
          SUMMARY: ${{ needs.generate-summary.outputs.summary }}
          ISSUES_CLOSED: ${{ needs.collect-metrics.outputs.issues_closed_count }}
          PRS_MERGED: ${{ needs.collect-metrics.outputs.prs_merged_count }}
          SUCCESS_RATE: ${{ needs.collect-metrics.outputs.agent_success_rate }}
        run: |
          set -euo pipefail

          DATE=$(date +%Y-%m-%d)

          # Build Discord message with embed
          MESSAGE=$(jq -n \
            --arg content "## ðŸ“Š Weekly Standup - ${DATE}" \
            --arg summary "$SUMMARY" \
            --arg issues "$ISSUES_CLOSED" \
            --arg prs "$PRS_MERGED" \
            --arg rate "$SUCCESS_RATE" \
            '{
              content: $content,
              embeds: [{
                title: "Summary",
                description: $summary,
                color: 5814783,
                fields: [
                  { name: "Issues Closed", value: $issues, inline: true },
                  { name: "PRs Merged", value: $prs, inline: true },
                  { name: "Pipeline Success", value: ($rate + "%"), inline: true }
                ],
                footer: { text: "Automated Weekly Standup" }
              }],
              username: "Jordan - PM",
              avatar_url: "https://api.dicebear.com/9.x/bottts/png?seed=JordanPM"
            }')

          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -d "$MESSAGE" \
            "$DISCORD_STANDUP_WEBHOOK_URL"

          echo "Posted to standup channel"

  # ============================================================================
  # Optionally post to additional channels
  # ============================================================================
  post-to-additional-channels:
    name: Post to Additional Channels
    needs: generate-summary
    if: inputs.additional_channels == true
    strategy:
      matrix:
        channel: [dev, product]
    runs-on: ubuntu-latest
    steps:
      - name: Post to ${{ matrix.channel }}
        env:
          DISCORD_DEV_WEBHOOK_URL: ${{ secrets.DISCORD_DEV_WEBHOOK_URL }}
          DISCORD_PRODUCT_WEBHOOK_URL: ${{ secrets.DISCORD_PRODUCT_WEBHOOK_URL }}
          SUMMARY: ${{ needs.generate-summary.outputs.summary }}
        run: |
          set -euo pipefail

          if [ "${{ matrix.channel }}" == "dev" ]; then
            WEBHOOK_URL="$DISCORD_DEV_WEBHOOK_URL"
          else
            WEBHOOK_URL="$DISCORD_PRODUCT_WEBHOOK_URL"
          fi

          DATE=$(date +%Y-%m-%d)

          MESSAGE=$(jq -n \
            --arg content "## ðŸ“Š Weekly Summary - ${DATE}\n\n$SUMMARY" \
            --arg username "Jordan - PM" \
            --arg avatar "https://api.dicebear.com/9.x/bottts/png?seed=JordanPM" \
            '{
              content: $content,
              username: $username,
              avatar_url: $avatar
            }')

          curl -sS -X POST \
            -H "Content-Type: application/json" \
            -d "$MESSAGE" \
            "$WEBHOOK_URL"

          echo "Posted to ${{ matrix.channel }} channel"

  # ============================================================================
  # Update DEVLOG.md with weekly entry
  # ============================================================================
  update-devlog:
    name: Update DEVLOG.md
    needs: [collect-metrics, generate-summary]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}

      - name: Append weekly entry
        env:
          SUMMARY: ${{ needs.generate-summary.outputs.summary }}
          ISSUES_CLOSED: ${{ needs.collect-metrics.outputs.issues_closed_count }}
          PRS_MERGED: ${{ needs.collect-metrics.outputs.prs_merged_count }}
          HOTFIXES: ${{ needs.collect-metrics.outputs.hotfixes_count }}
          SUCCESS_RATE: ${{ needs.collect-metrics.outputs.agent_success_rate }}
        shell: bash
        run: |
          set -euo pipefail

          DATE=$(date +%Y-%m-%d)

          if [ ! -f DEVLOG.md ]; then
            echo "# Development Log" > DEVLOG.md
            echo "" >> DEVLOG.md
            echo "Automated development activity log." >> DEVLOG.md
            echo "" >> DEVLOG.md
          fi

          {
            echo ""
            echo "## Weekly Summary [$DATE]"
            echo ""
            echo "$SUMMARY"
            echo ""
            echo "**Metrics:**"
            echo "* Issues closed: ${ISSUES_CLOSED}"
            echo "* PRs merged: ${PRS_MERGED}"
            echo "* Hotfixes: ${HOTFIXES}"
            echo "* Pipeline success rate: ${SUCCESS_RATE}%"
            echo ""
            echo "---"
          } >> DEVLOG.md

          echo "Appended weekly entry to DEVLOG.md"

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add DEVLOG.md
          git commit -m "docs: add weekly summary for $(date +%Y-%m-%d)" || echo "No changes to commit"
          git push || echo "Nothing to push"
