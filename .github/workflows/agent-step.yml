name: Agent Step

on:
  workflow_call:
    inputs:
      work_branch:
        description: "Remote branch created by the orchestrator for the issue"
        required: true
        type: string
      agent_name:
        description: "Name of the agent to run"
        required: true
        type: string
      phase:
        description: "Phase of execution (pre, main, post, review, fix)"
        required: true
        type: string
      issue_number:
        description: "Issue number being processed"
        required: true
        type: string
      issue_context:
        description: "Context summary from orchestrator"
        required: true
        type: string
      agent_prompts:
        description: "JSON object containing prompts for each agent"
        required: true
        type: string
      planning_context:
        description: "Context from planning agents"
        required: false
        type: string
        default: ""
      pr_number:
        description: "PR number for review/fix phase"
        required: false
        type: string
        default: ""
      review_feedback:
        description: "Review comments to address (for fix phase)"
        required: false
        type: string
        default: ""
      fix_iteration:
        description: "Current fix iteration 1-3 (for fix phase)"
        required: false
        type: string
        default: "1"
      # Resume mode inputs (for clarification response handling)
      is_resume:
        description: "Whether this is a resumed run after clarification"
        required: false
        type: string
        default: "false"
      clarification_response:
        description: "The clarification response from human (for resumed runs)"
        required: false
        type: string
        default: ""
    outputs:
      result:
        description: "Agent output result"
        value: ${{ jobs.run_agent.outputs.result }}
      success:
        description: "Whether the agent completed successfully"
        value: ${{ jobs.run_agent.outputs.success }}

concurrency:
  group: issue-${{ inputs.issue_number }}-${{ inputs.agent_name }}-${{ inputs.phase }}
  cancel-in-progress: false

jobs:
  run_agent:
    name: Run ${{ inputs.agent_name }} (${{ inputs.phase }})
    runs-on: ubuntu-latest
    outputs:
      result: ${{ steps.parse.outputs.result }}
      success: ${{ steps.parse.outputs.success }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}

      - name: Checkout work branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          ref: ${{ inputs.work_branch }}

      - name: Configure git + hard clean
        shell: bash
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Ensure we're truly on the branch, synced, and pristine
          git fetch origin "${{ inputs.work_branch }}"
          git checkout -B "${{ inputs.work_branch }}" "origin/${{ inputs.work_branch }}"
          git reset --hard
          git clean -ffdx

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Build MCP Discord (outside git worktree)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf /tmp/mcp-discord
          cp -R tools/mcp-discord /tmp/mcp-discord
          cd /tmp/mcp-discord
          npm ci
          npm run build

      - name: Build MCP Clarification (outside git worktree)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf /tmp/mcp-clarification
          cp -R tools/mcp-clarification /tmp/mcp-clarification
          cd /tmp/mcp-clarification
          npm ci
          npm run build

      - name: Create MCP config
        shell: bash
        run: |
          set -euo pipefail

          # Map agent names to friendly persona names (matches notify job usernames)
          AGENT="${{ inputs.agent_name }}"
          case "$AGENT" in
            documentation-sheriff) PERSONA="Riley - Docs" ;;
            infrastructure-engineer) PERSONA="Sam - Infra" ;;
            security-engineer) PERSONA="Casey - Security" ;;
            product-owner) PERSONA="Morgan - Product" ;;
            ux-designer) PERSONA="Drew - UX" ;;
            tech-lead) PERSONA="Taylor - Lead" ;;
            software-engineer) PERSONA="Alex - Dev" ;;
            test-engineer) PERSONA="Jamie - QA" ;;
            project-manager) PERSONA="Jordan - PM" ;;
            code-reviewer) PERSONA="Avery - Review" ;;
            *) PERSONA="$AGENT" ;;
          esac

          cat > /tmp/mcp-config.json << EOF
          {
            "mcpServers": {
              "discord": {
                "command": "node",
                "args": ["/tmp/mcp-discord/dist/index.js"],
                "env": {
                  "DISCORD_WEBHOOK_URL": "${{ secrets.DISCORD_DEV_WEBHOOK_URL }}",
                  "DISCORD_DEFAULT_CHANNEL_ID": "${{ vars.DISCORD_DEV_CHANNEL_ID || '1453129264118370434' }}",
                  "AGENT_NAME": "$PERSONA"
                }
              },
              "clarification": {
                "command": "node",
                "args": ["/tmp/mcp-clarification/dist/index.js"],
                "env": {
                  "GITHUB_TOKEN": "${{ secrets.GITHUB_TOKEN }}",
                  "GITHUB_REPOSITORY": "${{ github.repository }}",
                  "GITHUB_RUN_ID": "${{ github.run_id }}",
                  "GITHUB_SERVER_URL": "${{ github.server_url }}",
                  "ISSUE_NUMBER": "${{ inputs.issue_number }}",
                  "TEAM_LEAD_USERNAME": "${{ vars.TEAM_LEAD_USERNAME || '' }}",
                  "AGENT_NAME": "$PERSONA",
                  "AGENT_PHASE": "${{ inputs.phase }}"
                }
              }
            }
          }
          EOF

      # ========================================================================
      # ROLE-BASED PERMISSIONS: Comprehensive tool access per agent role
      # See: .github/workflows/claude-settings.yml for tool matrix reference
      # ========================================================================
      - name: Classify agent role and determine permissions
        id: exec_policy
        shell: bash
        run: |
          set -euo pipefail
          AGENT="${{ inputs.agent_name }}"
          PHASE="${{ inputs.phase }}"

          # Determine granular role class based on agent name
          case "$AGENT" in
            product-owner|ux-designer|tech-lead|project-manager)
              ROLE_CLASS="planning"
              ;;
            software-engineer)
              ROLE_CLASS="implementation"
              ;;
            infrastructure-engineer)
              ROLE_CLASS="infrastructure"
              ;;
            test-engineer)
              ROLE_CLASS="testing"
              ;;
            security-engineer)
              ROLE_CLASS="security"
              ;;
            documentation-sheriff)
              ROLE_CLASS="documentation"
              ;;
            code-reviewer)
              ROLE_CLASS="review"
              ;;
            *)
              ROLE_CLASS="unknown"
              ;;
          esac

          # Determine permission mode based on role and phase
          PERMISSION_MODE="acceptEdits"
          case "$PHASE" in
            main|post|fix)
              case "$ROLE_CLASS" in
                implementation|infrastructure|testing|security|documentation)
                  PERMISSION_MODE="bypassPermissions"
                  ;;
              esac
              ;;
          esac

          # Determine git write access
          ALLOW_GIT_WRITE="false"
          case "$ROLE_CLASS" in
            planning|implementation|infrastructure|testing|security|documentation)
              ALLOW_GIT_WRITE="true"
              ;;
          esac

          echo "permission_mode=$PERMISSION_MODE" >> "$GITHUB_OUTPUT"
          echo "role_class=$ROLE_CLASS" >> "$GITHUB_OUTPUT"
          echo "allow_git_write=$ALLOW_GIT_WRITE" >> "$GITHUB_OUTPUT"

          echo "Agent: $AGENT | Phase: $PHASE | Role: $ROLE_CLASS | Mode: $PERMISSION_MODE | Git Write: $ALLOW_GIT_WRITE"

      - name: Generate role-specific Claude settings
        id: settings
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .claude

          ROLE_CLASS="${{ steps.exec_policy.outputs.role_class }}"
          PERMISSION_MODE="${{ steps.exec_policy.outputs.permission_mode }}"

          # ================================================================
          # TOOL DEFINITIONS - Comprehensive access per role
          # ================================================================

          # Base tools for ALL agents
          BASE_TOOLS='"Read","Grep","Glob","Edit","Write"'

          # Git read tools (all agents can read)
          GIT_READ='"Bash(git status)","Bash(git log:*)","Bash(git diff:*)","Bash(git show:*)","Bash(git branch:*)"'

          # Git write tools (implementation/validation agents)
          GIT_WRITE='"Bash(git fetch:*)","Bash(git checkout:*)","Bash(git pull:*)","Bash(git rebase:*)","Bash(git add:*)","Bash(git commit:*)","Bash(git push:*)","Bash(git merge:*)","Bash(git stash:*)","Bash(git reset:*)","Bash(git clean:*)"'

          # File exploration tools
          FILE_TOOLS='"Bash(cat:*)","Bash(find:*)","Bash(ls:*)","Bash(head:*)","Bash(tail:*)","Bash(wc:*)","Bash(tree:*)","Bash(file:*)"'

          # Utility tools
          UTIL_TOOLS='"Bash(jq:*)","Bash(sed:*)","Bash(awk:*)","Bash(grep:*)","Bash(mkdir:*)","Bash(echo:*)","Bash(cp:*)","Bash(mv:*)","Bash(rm:*)","Bash(touch:*)","Bash(dirname:*)","Bash(basename:*)","Bash(realpath:*)","Bash(pwd)"'

          # Dotnet build/test tools
          DOTNET_BUILD='"Bash(dotnet build:*)","Bash(dotnet restore:*)","Bash(dotnet clean:*)","Bash(dotnet publish:*)"'
          DOTNET_TEST='"Bash(dotnet test:*)","Bash(dotnet run:*)"'

          # NPM build tools
          NPM_BUILD='"Bash(npm ci)","Bash(npm ci:*)","Bash(npm install)","Bash(npm install:*)","Bash(npm run build)","Bash(npm run build:*)","Bash(npx:*)"'

          # NPM test tools
          NPM_TEST='"Bash(npm test)","Bash(npm test:*)","Bash(npm run test)","Bash(npm run test:*)","Bash(npm run type-check)","Bash(npm run type-check:*)","Bash(npm run lint)","Bash(npm run lint:*)","Bash(npm run format:*)"'

          # Infrastructure-specific tools (CDK, AWS, Docker)
          CDK_TOOLS='"Bash(npx cdk:*)","Bash(cdk:*)","Bash(npx aws-cdk:*)"'
          AWS_TOOLS='"Bash(aws s3:*)","Bash(aws sts:*)","Bash(aws cloudformation:*)","Bash(aws ecs:*)","Bash(aws ecr:*)","Bash(aws logs:*)","Bash(aws lambda:*)","Bash(aws rds:*)"'
          DOCKER_TOOLS='"Bash(docker build:*)","Bash(docker compose:*)","Bash(docker ps:*)","Bash(docker images:*)","Bash(docker logs:*)","Bash(docker exec:*)","Bash(docker run:*)"'

          # Testing-specific tools (Jest, Playwright, Coverage)
          JEST_TOOLS='"Bash(npx jest:*)","Bash(jest:*)"'
          PLAYWRIGHT_TOOLS='"Bash(npx playwright:*)","Bash(playwright:*)"'
          COVERAGE_TOOLS='"Bash(npm run coverage)","Bash(npm run coverage:*)"'

          # Security-specific tools (Audit, Scanning)
          AUDIT_TOOLS='"Bash(npm audit)","Bash(npm audit:*)","Bash(dotnet list:*)","Bash(npx audit-ci:*)","Bash(npx snyk:*)"'
          SECURITY_AWS='"Bash(aws iam:*)","Bash(aws kms:*)","Bash(aws secretsmanager:*)"'

          # GitHub CLI tools (for code reviewer)
          GH_TOOLS='"Bash(gh pr:*)","Bash(gh issue:*)","Bash(gh api:*)","Bash(gh repo:*)","Bash(gh run:*)","Bash(gh workflow:*)"'

          # Denied tools (security - applies to all)
          DENY_TOOLS='"Bash(curl:*)","Bash(wget:*)","Bash(sudo:*)","Bash(chmod 777:*)","Bash(chown:*)","Bash(apt:*)","Bash(yum:*)","Bash(brew:*)"'

          # ================================================================
          # BUILD ALLOW LIST BASED ON ROLE CLASS
          # ================================================================
          case "$ROLE_CLASS" in
            planning)
              # Planning agents: read-only, file exploration, limited git
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$FILE_TOOLS"
              ;;

            implementation)
              # Software engineer: full development toolset
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$GIT_WRITE,$FILE_TOOLS,$UTIL_TOOLS,$DOTNET_BUILD,$DOTNET_TEST,$NPM_BUILD,$NPM_TEST"
              ;;

            infrastructure)
              # Infrastructure engineer: software engineer + CDK/AWS/Docker
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$GIT_WRITE,$FILE_TOOLS,$UTIL_TOOLS,$DOTNET_BUILD,$DOTNET_TEST,$NPM_BUILD,$NPM_TEST,$CDK_TOOLS,$AWS_TOOLS,$DOCKER_TOOLS"
              ;;

            testing)
              # Test engineer: validation + testing frameworks + coverage
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$GIT_WRITE,$FILE_TOOLS,$UTIL_TOOLS,$DOTNET_BUILD,$DOTNET_TEST,$NPM_BUILD,$NPM_TEST,$JEST_TOOLS,$PLAYWRIGHT_TOOLS,$COVERAGE_TOOLS"
              ;;

            security)
              # Security engineer: validation + audit tools + limited AWS
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$GIT_WRITE,$FILE_TOOLS,$UTIL_TOOLS,$DOTNET_BUILD,$DOTNET_TEST,$NPM_BUILD,$NPM_TEST,$AUDIT_TOOLS,$SECURITY_AWS"
              ;;

            documentation)
              # Documentation sheriff: minimal bash, git for doc commits, file exploration
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$GIT_WRITE,$FILE_TOOLS,$UTIL_TOOLS"
              ;;

            review)
              # Code reviewer: GitHub CLI + git write for issue context updates
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$GIT_WRITE,$FILE_TOOLS,$UTIL_TOOLS,$GH_TOOLS"
              ;;

            *)
              # Unknown role: base tools only for safety
              ALLOW_LIST="$BASE_TOOLS,$GIT_READ,$FILE_TOOLS"
              ;;
          esac

          # MCP tools - all agents get these
          MCP_ALLOWED="mcp__discord__discord_post_dev_update,mcp__clarification__request_clarification"

          # ================================================================
          # WRITE SETTINGS FILE
          # ================================================================
          cat > .claude/settings.local.json << EOF
          {
            "permissions": {
              "defaultMode": "$PERMISSION_MODE",
              "allow": [
                $ALLOW_LIST
              ],
              "deny": [
                $DENY_TOOLS
              ]
            }
          }
          EOF

          # Validate JSON
          if ! jq empty .claude/settings.local.json 2>/dev/null; then
            echo "ERROR: Generated invalid JSON"
            cat .claude/settings.local.json
            exit 1
          fi

          # Output the MCP allowed tools for claude_args
          echo "mcp_allowed=$MCP_ALLOWED" >> "$GITHUB_OUTPUT"

          echo "Generated settings for $ROLE_CLASS:"
          cat .claude/settings.local.json | jq .

      - name: Load agent definition
        id: definition
        run: |
          DEFINITION_PATH="working/agents/definitions/${{ inputs.agent_name }}.md"
          if [ -f "$DEFINITION_PATH" ]; then
            DELIM="EOF_$(openssl rand -hex 8)"
            echo "definition<<$DELIM" >> $GITHUB_OUTPUT
            cat "$DEFINITION_PATH" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "$DELIM" >> $GITHUB_OUTPUT
          else
            echo "definition=No definition file found" >> $GITHUB_OUTPUT
          fi

      - name: Load agent memory
        id: memory
        run: |
          MEMORY_PATH="working/agents/memory/${{ inputs.agent_name }}/MEMORY.md"
          if [ -f "$MEMORY_PATH" ]; then
            DELIM="EOF_$(openssl rand -hex 8)"
            echo "memory<<$DELIM" >> $GITHUB_OUTPUT
            cat "$MEMORY_PATH" >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "$DELIM" >> $GITHUB_OUTPUT
          else
            echo "memory=No memory file found" >> $GITHUB_OUTPUT
          fi

      - name: Load supplementary memory files
        id: supplementary
        run: |
          MEMORY_DIR="working/agents/memory/${{ inputs.agent_name }}"
          SUPPLEMENTARY=""
          if [ -d "$MEMORY_DIR" ]; then
            for file in "$MEMORY_DIR"/*.md; do
              if [ -f "$file" ] && [ "$(basename "$file")" != "MEMORY.md" ]; then
                SUPPLEMENTARY="$SUPPLEMENTARY\n\n## $(basename "$file" .md)\n$(cat "$file")"
              fi
            done
          fi
          DELIM="EOF_$(openssl rand -hex 8)"
          echo "files<<$DELIM" >> $GITHUB_OUTPUT
          echo -e "$SUPPLEMENTARY" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "$DELIM" >> $GITHUB_OUTPUT

      - name: Find issue context file
        id: issue_file
        run: |
          ISSUE_FILE=$(find working/issues -name "${{ inputs.issue_number }} *.md" 2>/dev/null | head -1)
          if [ -n "$ISSUE_FILE" ]; then
            echo "path=$ISSUE_FILE" >> $GITHUB_OUTPUT
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract agent prompt (non-fatal)
        id: prompt
        uses: actions/github-script@v7
        env:
          AGENT_PROMPTS_JSON: ${{ inputs.agent_prompts }}
        with:
          script: |
            const agentName = '${{ inputs.agent_name }}'.replace(/-/g, '_');

            const raw = (process.env.AGENT_PROMPTS_JSON || '').trim();
            if (!raw) {
              core.setOutput('task', 'No agent_prompts were provided. Read the issue context file and proceed according to your role + phase instructions.');
              core.setOutput('phase_config', '${{ inputs.phase }}');
              return;
            }

            try {
              let prompts = JSON.parse(raw);
              if (typeof prompts === 'string') prompts = JSON.parse(prompts);

              const agentConfig = prompts[agentName] || {};
              core.setOutput('task', agentConfig.prompt || 'No specific task assigned. Use your role + phase instructions to proceed.');
              core.setOutput('phase_config', agentConfig.phase || '${{ inputs.phase }}');
            } catch (e) {
              console.log(`Warning: Failed to parse agent_prompts JSON: ${e.message}`);
              console.log(`Raw input (first 500 chars): ${raw.slice(0, 500)}`);
              core.setOutput('task', 'No specific task assigned (JSON parse failed). Use your role + phase instructions to proceed.');
              core.setOutput('phase_config', '${{ inputs.phase }}');
            }

      - name: Build system prompt file
        env:
          CLARIFICATION_RESPONSE_TEXT: ${{ inputs.clarification_response }}
        run: |
          cat << 'EOF' > /tmp/system_prompt.txt
          # Agent: ${{ inputs.agent_name }}
          ## Phase: ${{ inputs.phase }}

          ## Your Definition
          ${{ steps.definition.outputs.definition }}

          ## Your Memory Guidelines
          ${{ steps.memory.outputs.memory }}

          ## Your Supplementary Memory
          ${{ steps.supplementary.outputs.files }}

          ## Working Directory
          Your memory space is at: working/agents/memory/${{ inputs.agent_name }}/
          You may read and write files in this directory to persist information.

          ## Issue Context
          ${{ inputs.issue_context }}

          ## Issue Context File
          The issue context file is at: ${{ steps.issue_file.outputs.path }}
          This file contains pre-planning information and should be updated with your findings.

          ## Planning Context
          ${{ inputs.planning_context }}

          ## Key Repository Files
          ### DEVLOG.md
          This is a LARGE development log file at the repository root.
          - DO NOT read the entire file
          - To get recent context: grep for "## Session" and read the latest entry

          ### ABOUT.md
          Contains product information, business requirements, and milestones.

          ### working/issues/
          Contains context files for each issue being processed.
          Your current issue file: ${{ steps.issue_file.outputs.path }}

          ## Phase-Specific Instructions
          EOF

          case "${{ inputs.agent_name }}" in
            "product-owner"|"ux-designer"|"tech-lead"|"project-manager")
              cat << 'PLAN_ONLY_EOF' >> /tmp/system_prompt.txt

          # ROLE BOUNDARY (PLANNING-ONLY)
          You are a PLANNING-ONLY agent.
          - You MUST NOT implement changes in application code, infrastructure, or tests.
          - You MUST NOT create commits, push branches, or open PRs.
          - You MAY edit ONLY:
            - the issue context file (working/issues/...)
            - your memory files (working/agents/memory/...)
          PLAN_ONLY_EOF
              ;;
          esac

          case "${{ inputs.phase }}" in
            "pre")
              cat << 'PHASE_EOF' >> /tmp/system_prompt.txt
          You are running in the PRE phase.
          - Gather context
          - Update issue context file with findings
          - Update memory as needed
          PHASE_EOF
              ;;
            "main")
              cat << 'PHASE_EOF' >> /tmp/system_prompt.txt
          You are running in the MAIN phase.
          - Execute your assigned task
          - Update issue context + memory
          - Implementation agents: commit only if you made changes
          PHASE_EOF
              ;;
            "post")
              cat << 'PHASE_EOF' >> /tmp/system_prompt.txt
          You are running in the POST phase.
          - Validate earlier work
          - Make necessary follow-ups
          - Update issue context + memory
          PHASE_EOF
              ;;
            "review")
              cat << 'PHASE_EOF' >> /tmp/system_prompt.txt
          You are running in the REVIEW phase.
          - Review PR #${{ inputs.pr_number }}
          - Leave review feedback
          PHASE_EOF
              ;;
            "fix")
              cat << PHASE_EOF >> /tmp/system_prompt.txt
          You are running in the FIX phase (iteration ${{ inputs.fix_iteration }}/3).
          - You are addressing code review feedback on PR #${{ inputs.pr_number }}
          - Focus ONLY on the specific issues raised in the review
          - Do NOT add new features or refactor unrelated code
          - Update the issue context file with what you fixed
          - The review feedback is below

          ## Review Feedback to Address
          ${{ inputs.review_feedback }}
          PHASE_EOF
              ;;
          esac

          # Add Discord MCP tool instructions for all agents
          cat << 'DISCORD_EOF' >> /tmp/system_prompt.txt

          ## Discord Updates (MCP Tool)
          You have access to the `discord_post_dev_update` MCP tool to post updates to the #dev Discord channel.
          Do this as you switch contexts or make significant progress in order to keep your team tightly informed.

          **Use for**:
          - **progress**: Milestone completions, significant task progress
          - **delay**: Blockers encountered, unexpected issues
          - **tech_debt**: Technical debt discoveries worth noting
          - **thinking**: Significant decisions or reasoning worth sharing

          **How to write messages:**
          - write like a dev in slack. lowercase, brief, no fluff.
          - no @everyone or @here. under 280 chars ideally, 500 max.
          - sound like a real person updating the team on what YOU are doing right now.
          - don't summarize the whole issue - just your current step.
          - no bullet points, no headers, just plain text.
          - one or two sentences max. conversational.
          - do NOT mention any contextual documents with "n/a"
          - post when you have something meaningful to share, not just to fill silence
          DISCORD_EOF

          # Add Clarification MCP tool instructions for all agents
          cat << 'CLARIFICATION_EOF' >> /tmp/system_prompt.txt

          ## Clarification Requests (MCP Tool)
          You have access to the `request_clarification` MCP tool to ask humans for information when you're blocked.

          **USE THIS TOOL WHEN:**
          - You need API keys, credentials, or secrets that weren't provided in the issue
          - Requirements are ambiguous and you need a human decision
          - You need access to external resources or services you don't have
          - The issue description is missing critical information you cannot infer

          **DO NOT USE FOR:**
          - Questions you can answer by reading the codebase
          - Implementation decisions you can reasonably make yourself
          - Things that are clearly specified in the issue or planning context
          - Stylistic choices or preferences - make a reasonable decision

          **How it works:**
          1. The tool posts a comment on the issue tagging the team lead
          2. It polls for a response (default 30 min timeout)
          3. If someone responds, you get their answer and can continue
          4. If no response, the workflow pauses and will auto-resume when someone replies

          **When calling:**
          - Be specific about what you need and why
          - Provide context about what you're trying to accomplish
          - Ask one clear question at a time
          CLARIFICATION_EOF

          # If this is a resumed run, inject the clarification response
          if [ "${{ inputs.is_resume }}" == "true" ] && [ -n "${{ inputs.clarification_response }}" ]; then
            cat << 'RESUME_EOF' >> /tmp/system_prompt.txt

          ## IMPORTANT: Clarification Response Available

          This is a RESUMED run. You previously asked for clarification and the team has responded.
          Their response is provided below. Use this information to continue your work.

          RESUME_EOF

            # Use environment variable to safely handle the response content
            echo "### Human Response:" >> /tmp/system_prompt.txt
            echo "" >> /tmp/system_prompt.txt
            echo "$CLARIFICATION_RESPONSE_TEXT" >> /tmp/system_prompt.txt
            echo "" >> /tmp/system_prompt.txt
            echo "---" >> /tmp/system_prompt.txt
            echo "" >> /tmp/system_prompt.txt
            echo "Continue your work using this information. Do NOT ask for clarification again on the same topic." >> /tmp/system_prompt.txt
          fi

      - name: Write agent output schema (file)
        id: schema # <--- Add ID
        run: |
          cat > /tmp/agent_output_schema.json <<'JSON'
          {
            "type": "object",
            "additionalProperties": false,
            "required": [
              "success",
              "summary",
              "files_changed",
              "commits_made",
              "memory_updated",
              "issue_context_updated",
              "blockers",
              "notes_for_next_agent"
            ],
            "properties": {
              "success": { "type": "boolean" },
              "summary": { "type": "string" },
              "files_changed": { "type": "array", "items": { "type": "string" } },
              "commits_made": { "type": "array", "items": { "type": "string" } },
              "memory_updated": { "type": "boolean" },
              "issue_context_updated": { "type": "boolean" },
              "blockers": { "type": "array", "items": { "type": "string" } },
              "notes_for_next_agent": { "type": "string" }
            }
          }
          JSON

          # Output the compact JSON string for the CLI arg
          echo "content=$(jq -c . /tmp/agent_output_schema.json)" >> "$GITHUB_OUTPUT"

      - name: Run agent
        id: agent
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.CLAUDE_WORKFLOW_TOKEN }}
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          claude_args: >-
            --mcp-config /tmp/mcp-config.json
            --model claude-opus-4-5-20251101
            --json-schema '${{ steps.schema.outputs.content }}'
            --max-turns 6000
            --system-prompt-file /tmp/system_prompt.txt
            --permission-mode ${{ steps.exec_policy.outputs.permission_mode }}
            --allowedTools ${{ steps.settings.outputs.mcp_allowed }}
          prompt: |
            ## Your Task
            ${{ steps.prompt.outputs.task }}

            Return ONLY the final JSON.

      - name: Auto-commit planning artifacts (issue context + memory)
        if: always() && steps.exec_policy.outputs.role_class == 'planning'
        shell: bash
        run: |
          set -euo pipefail
          git add working/issues working/agents/memory || true
          if git diff --cached --quiet; then
            echo "No planning artifacts changed; nothing to commit."
            exit 0
          fi
          git commit -m "chore: planning update for #${{ inputs.issue_number }} (${{ inputs.agent_name }})"

      - name: Auto-commit implementation/validation changes
        if: |
          always() && (
            steps.exec_policy.outputs.role_class == 'implementation' ||
            steps.exec_policy.outputs.role_class == 'infrastructure' ||
            steps.exec_policy.outputs.role_class == 'testing' ||
            steps.exec_policy.outputs.role_class == 'security' ||
            steps.exec_policy.outputs.role_class == 'documentation'
          )
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            if git diff --cached --quiet; then
              echo "Dirty tree, but nothing staged; skipping commit."
              exit 0
            fi
            git commit -m "chore: agent changes for #${{ inputs.issue_number }} (${{ inputs.agent_name }}:${{ inputs.phase }})"
          else
            echo "Working tree clean; nothing to commit."
          fi

      - name: Push work branch (with retry for concurrent agents)
        if: always() && steps.exec_policy.outputs.allow_git_write == 'true'
        shell: bash
        run: |
          set -euo pipefail
          BRANCH="${{ inputs.work_branch }}"
          MAX_RETRIES=5
          RETRY_DELAY=2

          for attempt in $(seq 1 $MAX_RETRIES); do
            echo "Push attempt $attempt of $MAX_RETRIES..."
            
            # Try to push
            if git push -u origin "$BRANCH" 2>&1; then
              echo "Push succeeded on attempt $attempt"
              exit 0
            fi
            
            # If we're on the last attempt, fail
            if [ "$attempt" -eq "$MAX_RETRIES" ]; then
              echo "ERROR: Push failed after $MAX_RETRIES attempts"
              exit 1
            fi
            
            echo "Push failed (likely concurrent update), rebasing and retrying..."
            
            # Before rebase, stash any uncommitted changes (rebase requires clean tree)
            STASHED=false
            if [ -n "$(git status --porcelain)" ]; then
              echo "Stashing uncommitted changes before rebase..."
              git stash push -u -m "auto-stash before rebase"
              STASHED=true
            fi
            
            # Fetch latest and rebase
            git fetch origin "$BRANCH"
            
            # Rebase our commits on top of remote
            if ! git rebase "origin/$BRANCH"; then
              echo "Rebase conflict detected, attempting auto-resolution..."
              # For agent-generated changes, prefer our changes on conflict
              git rebase --abort 2>/dev/null || true
              git pull --rebase -X theirs origin "$BRANCH" || {
                echo "ERROR: Could not resolve rebase conflicts automatically"
                git rebase --abort 2>/dev/null || true
                # Restore stashed changes before exiting
                if [ "$STASHED" = true ]; then
                  git stash pop || echo "Warning: stash pop failed after rebase error"
                fi
                exit 1
              }
            fi
            
            # Restore stashed changes after successful rebase
            if [ "$STASHED" = true ]; then
              echo "Restoring stashed changes..."
              git stash pop || {
                echo "Warning: stash pop failed, changes may be in stash list"
              }
            fi
            
            # Exponential backoff with jitter
            SLEEP_TIME=$((RETRY_DELAY * attempt + RANDOM % 3))
            echo "Waiting ${SLEEP_TIME}s before retry..."
            sleep "$SLEEP_TIME"
          done

      - name: Check for clarification checkpoint
        id: checkpoint
        if: always()
        shell: bash {0}
        run: |
          # Look for any checkpoint files created by the clarification MCP tool
          # Note: using bash {0} to avoid -e flag causing early exit
          CHECKPOINT_FILE=$(find /tmp -name "clarification-checkpoint-*.json" -type f 2>/dev/null | head -1 || echo "")
          if [ -n "$CHECKPOINT_FILE" ] && [ -f "$CHECKPOINT_FILE" ]; then
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "path=$CHECKPOINT_FILE" >> "$GITHUB_OUTPUT"
            CHECKPOINT_ID=$(basename "$CHECKPOINT_FILE" .json | sed 's/clarification-checkpoint-//')
            echo "id=$CHECKPOINT_ID" >> "$GITHUB_OUTPUT"
            echo "Found clarification checkpoint: $CHECKPOINT_FILE"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "No clarification checkpoint found"
          fi

      - name: Enrich checkpoint with orchestrator state
        if: always() && steps.checkpoint.outputs.found == 'true'
        shell: bash
        env:
          ORCHESTRATOR_STATE: |
            {
              "activate_documentation_sheriff": "${{ inputs.activate_documentation_sheriff || 'false' }}",
              "activate_infrastructure_engineer": "${{ inputs.activate_infrastructure_engineer || 'false' }}",
              "activate_product_owner": "${{ inputs.activate_product_owner || 'false' }}",
              "activate_project_manager": "${{ inputs.activate_project_manager || 'false' }}",
              "activate_security_engineer": "${{ inputs.activate_security_engineer || 'false' }}",
              "activate_software_engineer": "${{ inputs.activate_software_engineer || 'false' }}",
              "activate_tech_lead": "${{ inputs.activate_tech_lead || 'false' }}",
              "activate_test_engineer": "${{ inputs.activate_test_engineer || 'false' }}",
              "activate_ux_designer": "${{ inputs.activate_ux_designer || 'false' }}",
              "issue_context": ${{ toJSON(inputs.issue_context) }},
              "agent_prompts": ${{ toJSON(inputs.agent_prompts) }},
              "work_branch": "${{ inputs.work_branch }}",
              "is_hotfix": "false"
            }
        run: |
          set -euo pipefail
          CHECKPOINT_FILE="${{ steps.checkpoint.outputs.path }}"

          # Add orchestrator state and planning context to checkpoint
          jq --argjson orch_state "$ORCHESTRATOR_STATE" \
             --arg planning_context "${{ inputs.planning_context }}" \
             --arg issue_number "${{ inputs.issue_number }}" \
             '. + {
               orchestrator_state: $orch_state,
               resume_point: {
                 agent: .clarification.requesting_agent,
                 phase: .clarification.requesting_phase,
                 planning_context: $planning_context
               },
               issue: (.issue + { number: ($issue_number | tonumber) })
             }' "$CHECKPOINT_FILE" > /tmp/enriched-checkpoint.json

          mv /tmp/enriched-checkpoint.json "$CHECKPOINT_FILE"
          echo "Enriched checkpoint with orchestrator state"
          cat "$CHECKPOINT_FILE" | jq .

      - name: Upload clarification checkpoint artifact
        if: always() && steps.checkpoint.outputs.found == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: clarification-checkpoint-${{ steps.checkpoint.outputs.id }}
          path: ${{ steps.checkpoint.outputs.path }}
          retention-days: 30

      - name: Parse agent output (defensive)
        id: parse
        if: always()
        uses: actions/github-script@v7
        env:
          RAW_STRUCTURED: ${{ steps.agent.outputs.structured_output }}
          RAW_RESULT: ${{ steps.agent.outputs.result }}
        with:
          script: |
            const rawStructured = (process.env.RAW_STRUCTURED || '').trim();
            const rawResult = (process.env.RAW_RESULT || '').trim();
            const raw = rawStructured || rawResult;

            const tryParse = (s) => { try { return JSON.parse(s); } catch { return null; } };

            let parsed = tryParse(raw);

            if (!parsed && raw) {
              const cleaned = raw
                .replace(/<thinking[\s\S]*?<\/thinking>/gi, "")
                .replace(/<analysis[\s\S]*?<\/analysis>/gi, "")
                .replace(/```(?:json)?/gi, "")
                .replace(/```/g, "")
                .trim();

              const start = cleaned.indexOf("{");
              const end = cleaned.lastIndexOf("}");
              if (start !== -1 && end !== -1 && end > start) {
                parsed = tryParse(cleaned.slice(start, end + 1));
              }
            }

            if (!parsed) {
              throw new Error("Agent output was not valid JSON.");
            }

            core.setOutput('success', String(!!parsed.success));
            core.setOutput('result', JSON.stringify(parsed));
            core.setOutput('has_result', 'true');

      # Submit PR review to GitHub (code-reviewer only)
      # This converts the agent's JSON output into an actual GitHub PR review
      # Uses PR_REVIEW_PAT (different user than PR author) so auto-merge works correctly
      - name: Submit PR review (code-reviewer only)
        if: |
          always() &&
          inputs.agent_name == 'code-reviewer' &&
          (inputs.phase == 'review' || inputs.phase == 'fix') &&
          steps.parse.outputs.has_result == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PR_REVIEW_PAT }}
          script: |
            // Defensive parsing pattern - matches orchestrator and parse step
            const resultJson = (process.env.AGENT_RESULT || '').trim();

            if (!resultJson) {
              console.log('No agent result available, skipping review submission');
              return;
            }

            let result;
            try {
              result = JSON.parse(resultJson);
            } catch (e) {
              console.log('Failed to parse agent result:', e.message);
              console.log('Raw value:', resultJson.slice(0, 500));
              return;
            }

            const prNumber = parseInt('${{ inputs.pr_number }}');

            if (!prNumber) {
              console.log('No PR number provided, skipping review submission');
              return;
            }

            // Determine review event type from agent output
            const isApproved = result.approved === true || result.review_status === 'APPROVED';
            const event = isApproved ? 'APPROVE' : 'REQUEST_CHANGES';

            // Build review body from agent output
            let body = result.summary || '';

            if (!isApproved && result.blocking_issues?.length > 0) {
              body += '\n\n## Blocking Issues\n';
              for (const issue of result.blocking_issues) {
                body += `\n- **${issue.file}${issue.line ? `:${issue.line}` : ''}**: ${issue.issue}`;
                if (issue.suggestion) {
                  body += `\n  - Suggestion: ${issue.suggestion}`;
                }
              }
            }

            if (result.suggestions?.length > 0) {
              body += '\n\n## Suggestions\n';
              for (const s of result.suggestions) {
                body += `\n- **${s.file}${s.line ? `:${s.line}` : ''}**: ${s.suggestion}`;
              }
            }

            console.log(`Submitting ${event} review for PR #${prNumber}`);

            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              event: event,
              body: body || (isApproved ? 'LGTM! All requirements met.' : 'Changes requested - see blocking issues above.')
            });

            console.log(`Review submitted: ${event}`)
        env:
          AGENT_RESULT: ${{ steps.parse.outputs.result }}
